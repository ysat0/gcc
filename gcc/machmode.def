/* This file contains the definitions and documentation for the
   machine modes used in the GNU compiler.
   Copyright (C) 1987, 1992, 1994, 1997, 1998, 2000, 2003
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */


/* This file defines all the MACHINE MODES used by GCC.

   A machine mode specifies a size and format of data
   at the machine level.

   Each RTL expression has a machine mode.

   At the syntax tree level, each ..._TYPE and each ..._DECL node
   has a machine mode which describes data of that type or the
   data of the variable declared.  */

/* This file is included by the genmodes program.  Its text is the
   body of a function.  Do not rely on this, it will change in the
   future.

   The following statements can be used in this file -- all have
   the form of a C macro call.  In their arguments:

   A CLASS argument must be one of the constants defined in
   mode-classes.def, less the leading MODE_ prefix; some statements
   that take CLASS arguments have restructions on which classes are
   acceptable.  For instance, INT.

   A MODE argument must be the printable name of a machine mode,
   without quotation marks or trailing "mode".  For instance, SI.

   A BITSIZE, BYTESIZE, or COUNT argument must be a positive integer
   constant.

   Order matters in this file in so far as statements which refer to
   other modes must appear after the modes they refer to.  However,
   statements which do not refer to other modes may appear in any
   order.

     RANDOM_MODE (MODE);
        declares MODE to be of class RANDOM.

     CC_MODE (MODE);
        declares MODE to be of class CC.

     INT_MODE (MODE, BYTESIZE);
        declares MODE to be of class INT and BYTESIZE bytes wide.
	All of the bits of its representation are significant.

     FRACTIONAL_INT_MODE (MODE, BITSIZE, BYTESIZE);
        declares MODE to be of class INT, BYTESIZE bytes wide in
	storage, but with only BITSIZE significant bits.

     FLOAT_MODE (MODE, BYTESIZE);
        declares MODE to be of class FLOAT and BYTESIZE bytes wide.
	All of the bits of its representation are significant.

     FRACTIONAL_FLOAT_MODE (MODE, BITSIZE, BYTESIZE);
        declares MODE to be of class FLOAT, BYTESIZE bytes wide in
	storage, but with only BITSIZE significant bits.

     PARTIAL_INT_MODE (MODE);
        declares a mode of class PARTIAL_INT with the same size as
	MODE (which must be an INT mode).  The name of the new mode
	is made by prefixing a P to the name MODE.  This statement
	may grow a BITSIZE argument in the future.

     VECTOR_MODE (CLASS, MODE, COUNT);
        Declare a vector mode whose component mode is MODE (of class
	CLASS) with COUNT components.  CLASS must be INT or FLOAT.
	The name of the vector mode takes the form VnX where n is
	COUNT in decimal and X is MODE.

     VECTOR_MODES (CLASS, WIDTH);
        For all modes presently declared in class CLASS, construct
	corresponding vector modes having width WIDTH.  Modes whose
	byte sizes do not evenly divide WIDTH are ignored, as are
	modes that would produce vector modes with only one component,
	and modes smaller than one byte (if CLASS is INT) or smaller
	than two bytes (if CLASS is FLOAT).  CLASS must be INT or
	FLOAT.  The names follow the same rule as VECTOR_MODE uses.

     COMPLEX_MODES (CLASS);
        For all modes presently declared in class CLASS, construct
	corresponding complex modes.  Modes smaller than one byte
	are ignored.  For FLOAT modes, the names are derived by
	replacing the 'F' in the mode name with a 'C'.  (It is an
	error if there is no 'F'.  For INT modes, the names are
	derived by prefixing a C to the name.

     BITS_PER_UNIT (COUNT);
        Sets the number of bits in a machine byte (least addressable
	unit).  If this statement does not appear, the default is 8.

   Note: If a mode is ever made which is more than 255 bytes wide,
   machmode.h and genmodes.c will have to be changed to allocate
   more space for the mode_size and mode_alignment arrays.  */

/* VOIDmode is used when no mode needs to be specified,
   as for example on CONST_INT RTL expressions.  */
RANDOM_MODE (VOID);

/* BLKmode is used for structures, arrays, etc.
   that fit no more specific mode.  */
RANDOM_MODE (BLK);

/* Single bit mode used for booleans.  */
FRACTIONAL_INT_MODE (BI, 1, 1);

/* Basic integer modes.  */
INT_MODE (QI, 1);
INT_MODE (HI, 2);
INT_MODE (SI, 4);
INT_MODE (DI, 8);
INT_MODE (TI, 16);
INT_MODE (OI, 32);

/* Pointers on some machines use these types to distinguish them from
   ints.  Useful if a pointer is 4 bytes but has some bits that are
   not significant, so it is really not quite as wide as an integer.  */
PARTIAL_INT_MODE (QI);
PARTIAL_INT_MODE (HI);
PARTIAL_INT_MODE (SI);
PARTIAL_INT_MODE (DI);

/* Basic floating point modes.  */
FLOAT_MODE (QF, 1);	/* C4x single precision */
FLOAT_MODE (HF, 2);	/* C4x double precision */
FLOAT_MODE (TQF, 3);	/* MIL-STD-1750a */
FLOAT_MODE (SF, 4);
FLOAT_MODE (DF, 8);
FLOAT_MODE (XF, 12);	/* IEEE extended (80-bit) */
FLOAT_MODE (TF, 16);

/* Basic CC modes.  */
CC_MODE (CC);

/* Allow the target to specify additional modes of various kinds.  */
#if HAVE_EXTRA_MODES
# define CC(X) CC_MODE(X);  /* backward compatibility, temporary */
# include EXTRA_MODES_FILE
# undef CC
#endif

/* Complex modes.  */
COMPLEX_MODES (INT);
COMPLEX_MODES (FLOAT);

/* Vector modes.  */
VECTOR_MODES (INT, 2);        /*                 V2QI */
VECTOR_MODES (INT, 4);        /*            V4QI V2HI */
VECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI */
VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */
/* VECTOR_MODES (INT, 32);             V8SI V4DI      */
/* VECTOR_MODES (INT, 64);             V8DI           */

VECTOR_MODE (INT, SI, 8)
VECTOR_MODE (INT, DI, 4);
VECTOR_MODE (INT, DI, 8);

VECTOR_MODE (INT, DI, 1);  /* PPC uses this.  Why not plain DI? */

VECTOR_MODES (FLOAT, 4);      /*                 V2HF */
VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */
VECTOR_MODES (FLOAT, 16);     /*       V8HF V4SF V2DF */
/* VECTOR_MODES (FLOAT, 32);           V8SF V4DF      */
/* VECTOR_MODES (FLOAT, 64);     V16SF V8DF           */

VECTOR_MODE (FLOAT, SF, 8);
VECTOR_MODE (FLOAT, SF, 16);
VECTOR_MODE (FLOAT, DF, 4);
VECTOR_MODE (FLOAT, DF, 8);

/* The symbol Pmode stands for one of the above machine modes (usually SImode).
   The tm.h file specifies which one.  It is not a distinct mode.  */

/*
Local variables:
mode:c
version-control: t
End:
*/
