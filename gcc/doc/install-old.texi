@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file install.texi.

@ifnothtml
@comment node-name,     next,          previous, up
@node    Old, GNU Free Documentation License, Specific, Top
@end ifnothtml
@html
<h1 align="center">Old installation documentation</h1>
@end html
@ifnothtml
@chapter Old installation documentation
@end ifnothtml

Note most of this information is out of date and superseded by the
previous chapters of this manual.  It is provided for historical
reference only, because of a lack of volunteers to merge it into the
main manual.

@ifnothtml
@menu
* Configurations::    Configurations Supported by GCC.
* Cross-Compiler::   Building and installing a cross-compiler.
@end menu
@end ifnothtml

Here is the procedure for installing GCC on a GNU or Unix system.

@enumerate
@item
If you have chosen a configuration for GCC which requires other GNU
tools (such as GAS or the GNU linker) instead of the standard system
tools, install the required tools in the build directory under the names
@file{as}, @file{ld} or whatever is appropriate.

Alternatively, you can do subsequent compilation using a value of the
@code{PATH} environment variable such that the necessary GNU tools come
before the standard system tools.

@item
Specify the host, build and target machine configurations.  You do this
when you run the @file{configure} script.

The @dfn{build} machine is the system which you are using, the
@dfn{host} machine is the system where you want to run the resulting
compiler (normally the build machine), and the @dfn{target} machine is
the system for which you want the compiler to generate code.

If you are building a compiler to produce code for the machine it runs
on (a native compiler), you normally do not need to specify any operands
to @file{configure}; it will try to guess the type of machine you are on
and use that as the build, host and target machines.  So you don't need
to specify a configuration when building a native compiler unless
@file{configure} cannot figure out what your configuration is or guesses
wrong.

In those cases, specify the build machine's @dfn{configuration name}
with the @option{--host} option; the host and target will default to be
the same as the host machine.  (If you are building a cross-compiler,
see @ref{Cross-Compiler}.)

Here is an example:

@smallexample
./configure --host=sparc-sun-sunos4.1
@end smallexample

A configuration name may be canonical or it may be more or less
abbreviated.

A canonical configuration name has three parts, separated by dashes.
It looks like this: @samp{@var{cpu}-@var{company}-@var{system}}.
(The three parts may themselves contain dashes; @file{configure}
can figure out which dashes serve which purpose.)  For example,
@samp{m68k-sun-sunos4.1} specifies a Sun 3.

You can also replace parts of the configuration by nicknames or aliases.
For example, @samp{sun3} stands for @samp{m68k-sun}, so
@samp{sun3-sunos4.1} is another way to specify a Sun 3.

You can specify a version number after any of the system types, and some
of the CPU types.  In most cases, the version is irrelevant, and will be
ignored.  So you might as well specify the version if you know it.

See @ref{Configurations}, for a list of supported configuration names and
notes on many of the configurations.  You should check the notes in that
section before proceeding any further with the installation of GCC@.

@end enumerate

@ifnothtml
@node Configurations, Cross-Compiler, , Old
@section Configurations Supported by GCC
@end ifnothtml
@html
<h2>@anchor{Configurations}Configurations Supported by GCC</h2>
@end html
@cindex configurations supported by GCC

Here are the possible CPU types:

@quotation
@c gmicro, fx80, spur and tahoe omitted since they don't work.
1750a, a29k, alpha, arm, avr, c@var{n}, clipper, dsp16xx, elxsi, fr30, h8300,
hppa1.0, hppa1.1, i370, i386, i486, i586, i686, i786, i860, i960, ip2k, m32r,
m68000, m68k, m6811, m6812, m88k, mcore, mips, mipsel, mips64, mips64el,
mn10200, mn10300, ns32k, pdp11, powerpc, powerpcle, romp, rs6000, sh, sparc,
sparclite, sparc64, v850, vax, we32k.
@end quotation

Here are the recognized company names.  As you can see, customary
abbreviations are used rather than the longer official names.

@c What should be done about merlin, tek*, dolphin?
@quotation
acorn, alliant, altos, apollo, apple, att, bull,
cbm, convergent, convex, crds, dec, dg, dolphin,
elxsi, encore, harris, hitachi, hp, ibm, intergraph, isi,
mips, motorola, ncr, next, ns, omron, plexus,
sequent, sgi, sony, sun, tti, unicom, wrs.
@end quotation

The company name is meaningful only to disambiguate when the rest of
the information supplied is insufficient.  You can omit it, writing
just @samp{@var{cpu}-@var{system}}, if it is not needed.  For example,
@samp{vax-ultrix4.2} is equivalent to @samp{vax-dec-ultrix4.2}.

Here is a list of system types:

@quotation
386bsd, aix, acis, amigaos, aos, aout, aux, bosx, bsd, clix, coff, ctix, cxux,
dgux, dynix, ebmon, ecoff, elf, esix, freebsd, hms, genix, gnu, linux,
linux-gnu, hiux, hpux, iris, irix, isc, luna, lynxos, mach, minix, msdos, mvs,
netbsd, newsos, nindy, ns, osf, osfrose, ptx, riscix, riscos, rtu, sco, sim,
solaris, sunos, sym, sysv, udi, ultrix, unicos, uniplus, unos, vms, vsta,
vxworks, winnt, xenix.
@end quotation

@noindent
You can omit the system type; then @file{configure} guesses the
operating system from the CPU and company.

You can add a version number to the system type; this may or may not
make a difference.  For example, you can write @samp{bsd4.3} or
@samp{bsd4.4} to distinguish versions of BSD@.  In practice, the version
number is most needed for @samp{sysv3} and @samp{sysv4}, which are often
treated differently.

@samp{linux-gnu} is the canonical name for the GNU/Linux target; however
GCC will also accept @samp{linux}.  The version of the kernel in use is
not relevant on these systems.  A suffix such as @samp{libc1} or @samp{aout}
distinguishes major versions of the C library; all of the suffixed versions
are obsolete.

If you specify an impossible combination such as @samp{i860-dg-vms},
then you may get an error message from @file{configure}, or it may
ignore part of the information and do the best it can with the rest.
@file{configure} always prints the canonical name for the alternative
that it used.  GCC does not support all possible alternatives.

Often a particular model of machine has a name.  Many machine names are
recognized as aliases for CPU/company combinations.  Thus, the machine
name @samp{sun3}, mentioned above, is an alias for @samp{m68k-sun}.
Sometimes we accept a company name as a machine name, when the name is
popularly used for a particular machine.  Here is a table of the known
machine names:

@quotation
3300, 3b1, 3b@var{n}, 7300, altos3068, altos,
apollo68, att-7300, balance,
convex-c@var{n}, crds, decstation-3100,
decstation, delta, encore,
fx2800, gmicro, hp7@var{nn}, hp8@var{nn},
hp9k2@var{nn}, hp9k3@var{nn}, hp9k7@var{nn},
hp9k8@var{nn}, iris4d, iris, isi68,
m3230, magnum, merlin, miniframe,
mmax, news-3600, news800, news, next,
pbd, pc532, pmax, powerpc, powerpcle, ps2, risc-news,
rtpc, sun2, sun386i, sun386, sun3,
sun4, symmetry, tower-32, tower.
@end quotation

@noindent
Remember that a machine name specifies both the cpu type and the company
name.
If you want to install your own homemade configuration files, you can
use @samp{local} as the company name to access them.  If you use
configuration @samp{@var{cpu}-local}, the configuration name
without the cpu prefix
is used to form the configuration file names.

Thus, if you specify @samp{m68k-local}, configuration uses
files @file{m68k.md}, @file{local.h}, @file{m68k.c},
@file{xm-local.h}, @file{t-local}, and @file{x-local}, all in the
directory @file{config/m68k}.

@ifnothtml
@node Cross-Compiler, , Configurations, Old
@section Building and Installing a Cross-Compiler
@end ifnothtml
@html
<h2>@anchor{Cross-Compiler}Building and Installing a Cross-Compiler</h2>
@end html
@cindex cross-compiler, installation

GCC can function as a cross-compiler for many machines, but not all.

@itemize @bullet
@item
Cross-compilers for the Mips as target using the Mips assembler
currently do not work, because the auxiliary programs
@file{mips-tdump.c} and @file{mips-tfile.c} can't be compiled on
anything but a Mips.  It does work to cross compile for a Mips
if you use the GNU assembler and linker.

@item
Cross-compilers between machines with different floating point formats
have not all been made to work.  GCC now has a floating point
emulator with which these can work, but each target machine description
needs to be updated to take advantage of it.

@item
Cross-compilation between machines of different word sizes is
somewhat problematic and sometimes does not work.
@end itemize

Since GCC generates assembler code, you probably need a
cross-assembler that GCC can run, in order to produce object files.
If you want to link on other than the target machine, you need a
cross-linker as well.  You also need header files and libraries suitable
for the target machine that you can install on the host machine.

@ifnothtml
@menu
* Steps of Cross::      Using a cross-compiler involves several steps
                          that may be carried out on different machines.
* Configure Cross::     Configuring a cross-compiler.
* Tools and Libraries:: Where to put the linker and assembler, and the C library.
* Cross Headers::       Finding and installing header files
                          for a cross-compiler.
* Build Cross::         Actually compiling the cross-compiler.
@end menu
@end ifnothtml

@ifnothtml
@node Steps of Cross, Configure Cross, , Cross-Compiler
@subsection Steps of Cross-Compilation
@end ifnothtml
@html
<h2>Steps of Cross-Compilation</h2>
@end html

To compile and run a program using a cross-compiler involves several
steps:

@itemize @bullet
@item
Run the cross-compiler on the host machine to produce assembler files
for the target machine.  This requires header files for the target
machine.

@item
Assemble the files produced by the cross-compiler.  You can do this
either with an assembler on the target machine, or with a
cross-assembler on the host machine.

@item
Link those files to make an executable.  You can do this either with a
linker on the target machine, or with a cross-linker on the host
machine.  Whichever machine you use, you need libraries and certain
startup files (typically @file{crt@dots{}.o}) for the target machine.
@end itemize

It is most convenient to do all of these steps on the same host machine,
since then you can do it all with a single invocation of GCC@.  This
requires a suitable cross-assembler and cross-linker.  For some targets,
the GNU assembler and linker are available.

@ifnothtml
@node Configure Cross, Tools and Libraries, Steps of Cross, Cross-Compiler
@subsection Configuring a Cross-Compiler
@end ifnothtml
@html
<h2>Configuring a Cross-Compiler</h2>
@end html

To build GCC as a cross-compiler, you start out by running
@file{configure}.  Use the @option{--target=@var{target}} to specify the
target type.  If @file{configure} was unable to correctly identify the
system you are running on, also specify the @option{--build=@var{build}}
option.  For example, here is how to configure for a cross-compiler that
produces code for an HP 68030 system running BSD on a system that
@file{configure} can correctly identify:

@smallexample
./configure --target=m68k-hp-bsd4.3
@end smallexample

@ifnothtml
@node Tools and Libraries, Cross Headers, Configure Cross, Cross-Compiler
@subsection Tools and Libraries for a Cross-Compiler
@end ifnothtml
@html
<h2>Tools and Libraries for a Cross-Compiler</h2>
@end html

If you have a cross-assembler and cross-linker available, you should
install them now.  Put them in the directory
@file{/usr/local/@var{target}/bin}.  Here is a table of the tools
you should put in this directory:

@table @file
@item as
This should be the cross-assembler.

@item ld
This should be the cross-linker.

@item ar
This should be the cross-archiver: a program which can manipulate
archive files (linker libraries) in the target machine's format.

@item ranlib
This should be a program to construct a symbol table in an archive file.
@end table

The installation of GCC will find these programs in that directory,
and copy or link them to the proper place to for the cross-compiler to
find them when run later.

The easiest way to provide these files is to build the Binutils package
and GAS@.  Configure them with the same @option{--host} and @option{--target}
options that you use for configuring GCC, then build and install
them.  They install their executables automatically into the proper
directory.  Alas, they do not support all the targets that GCC
supports.

If you want to install libraries to use with the cross-compiler, such as
a standard C library, put them in the directory
@file{/usr/local/@var{target}/lib}; installation of GCC copies
all the files in that subdirectory into the proper place for GCC to
find them and link with them.  Here's an example of copying some
libraries from a target machine:

@example
ftp @var{target-machine}
lcd /usr/local/@var{target}/lib
cd /lib
get libc.a
cd /usr/lib
get libg.a
get libm.a
quit
@end example

@noindent
The precise set of libraries you'll need, and their locations on
the target machine, vary depending on its operating system.

@cindex start files
Many targets require ``start files'' such as @file{crt0.o} and
@file{crtn.o} which are linked into each executable; these too should be
placed in @file{/usr/local/@var{target}/lib}.  There may be several
alternatives for @file{crt0.o}, for use with profiling or other
compilation options.  Check your target's definition of
@code{STARTFILE_SPEC} to find out what start files it uses.
Here's an example of copying these files from a target machine:

@example
ftp @var{target-machine}
lcd /usr/local/@var{target}/lib
prompt
cd /lib
mget *crt*.o
cd /usr/lib
mget *crt*.o
quit
@end example

@ifnothtml
@node Cross Headers, Build Cross, Tools and Libraries, Cross-Compiler
@subsection Cross-Compilers and Header Files
@end ifnothtml
@html
<h2>Cross-Compilers and Header Files</h2>
@end html

If you are cross-compiling a standalone program or a program for an
embedded system, then you may not need any header files except the few
that are part of GCC (and those of your program).  However, if you
intend to link your program with a standard C library such as
@file{libc.a}, then you probably need to compile with the header files
that go with the library you use.

The GNU C compiler does not come with these files, because (1) they are
system-specific, and (2) they belong in a C library, not in a compiler.

If the GNU C library supports your target machine, then you can get the
header files from there (assuming you actually use the GNU library when
you link your program).

If your target machine comes with a C compiler, it probably comes with
suitable header files also.  If you make these files accessible from the host
machine, the cross-compiler can use them also.

Otherwise, you're on your own in finding header files to use when
cross-compiling.

When you have found suitable header files, you should put them in the
directory @file{/usr/local/@var{target}/include}, before building the
cross compiler.  Then installation will run fixincludes properly and
install the corrected versions of the header files where the compiler
will use them.

Provide the header files before you build the cross-compiler, because
the build stage actually runs the cross-compiler to produce parts of
@file{libgcc.a}.  (These are the parts that @emph{can} be compiled with
GCC@.)  Some of them need suitable header files.

Here's an example showing how to copy the header files from a target
machine.  On the target machine, do this:

@example
(cd /usr/include; tar cf - .) > tarfile
@end example

Then, on the host machine, do this:

@example
ftp @var{target-machine}
lcd /usr/local/@var{target}/include
get tarfile
quit
tar xf tarfile
@end example

@ifnothtml
@node Build Cross, , Cross Headers, Cross-Compiler
@subsection Actually Building the Cross-Compiler
@end ifnothtml
@html
<h2>Actually Building the Cross-Compiler</h2>
@end html

Now you can proceed just as for compiling a single-machine compiler
through the step of building stage 1.

Do not try to build stage 2 for a cross-compiler.  It doesn't work to
rebuild GCC as a cross-compiler using the cross-compiler, because
that would produce a program that runs on the target machine, not on the
host.  For example, if you compile a 386-to-68030 cross-compiler with
itself, the result will not be right either for the 386 (because it was
compiled into 68030 code) or for the 68030 (because it was configured
for a 386 as the host).  If you want to compile GCC into 68030 code,
whether you compile it on a 68030 or with a cross-compiler on a 386, you
must specify a 68030 as the host when you configure it.

To install the cross-compiler, use @samp{make install}, as usual.
