#!/bin/sh
#
#  Copyright (C) 2003 Free Software Foundation, Inc.
#  Contributed by Neil Booth, May 2003.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any
# later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Usage: opts.sh outfile.c outfile.h file1.opt [file2.opt, ...]

# Always operate in the C locale.
LANG=C
LANGUAGE=C
LC_ALL=C
export LANG LANGUAGE LC_ALL

# Set AWK if environment has not already set it.
AWK=${AWK-awk}

SORT=sort		# Could be /bin/sort or /usr/bin/sort

C_FILE=$1; shift
H_FILE=$1; shift

${AWK} '
	BEGIN{ RS=""; FS="\n" }
	# Ignore comments and blank lines
	/^[ \t]*(;|$)/	{ next }
	/^[^ \t]/ 	{ gsub ("\n", "\034", $0); print }
' "$@" | ${SORT} | ${AWK} '
    function switch_flags (langs,   flags)
    {
	langs = ":" langs ":"
	gsub( " ", ":", langs)
	flags = "0"
        if (langs ~ ":C:") flags = flags " | CL_C"
        if (langs ~ ":ObjC:") flags = flags " | CL_OBJC"
        if (langs ~ ":C\\+\\+:") flags = flags " | CL_CXX"
        if (langs ~ ":ObjC\\+\\+:") flags = flags " | CL_OBJCXX"
        if (langs ~ ":F77:") flags = flags " | CL_F77"
        if (langs ~ ":Java:") flags = flags " | CL_JAVA"
        if (langs ~ ":Ada:") flags = flags " | CL_ADA"
        if (langs ~ ":Tree:") flags = flags " | CL_TREELANG"
        if (langs ~ ":Common:") flags = flags " | CL_COMMON"
        if (langs ~ ":Joined:") flags = flags " | CL_JOINED"
        if (langs ~ ":Separate:") flags = flags " | CL_SEPARATE"
        if (langs ~ ":RejectNegative:") flags = flags " | CL_REJECT_NEGATIVE"
	sub( "^0 \\| ", "", flags )
	return flags
    }

    BEGIN {
	FS = "\034"
	n_opts = 0
    }

# Collect the text and flags of each option into an array
    {
	opts[n_opts] = $1
	flags[n_opts] = $2
	n_opts++;
    }

# Dump out an enumeration into a .h file, and an array of options into a
# C file.  Combine the flags of duplicate options.
    END {
	c_file = "'${C_FILE}'"
	h_file = "'${H_FILE}'"
	comma = ","

	print "/* This file is auto-generated by opts.sh.  */\n" > h_file
	print "enum opt_code\n{"			>> h_file

	print "/* This file is auto-generated by opts.sh.  */\n" > c_file
	print "#include \"" h_file "\""			>> c_file
	print "#include \"opts.h\"\n"			>> c_file
	print "const unsigned int cl_options_count = N_OPTS;\n" >> c_file
	print "const struct cl_option cl_options[] =\n{" >> c_file

	for (i = 0; i < n_opts; i++) {
	    while( i + 1 != n_opts && opts[i] == opts[i + 1] ) {
		flags[i + 1] = flags[i] " " flags[i + 1];
		i++;
	    }

	    enum = "OPT_" opts[i]
	    gsub( "[^A-Za-z0-9]", "_", enum)
	    s = substr("                                  ", length (opts[i]))
	    if (i + 1 == n_opts)
		comma = ""

	    printf("  %s,%s/* -%s */\n", enum, s, opts[i]) >> h_file
	    printf("  { \"%s\", %u, %s }%s\n", opts[i], \
		length(opts[i]), switch_flags(flags[i]), comma) >> c_file
	}

	print "  N_OPTS\n};"				>> h_file
	print "};"					>> c_file
    }
'
