#!/bin/sh
#
#  Copyright (C) 2003 Free Software Foundation, Inc.
#  Contributed by Neil Booth, May 2003.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any
# later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Usage: opts.sh outfile.c outfile.h file1.opt [file2.opt, ...]

# Always operate in the C locale.
LANG=C
LANGUAGE=C
LC_ALL=C
export LANG LANGUAGE LC_ALL

# Set AWK if environment has not already set it.
AWK=${AWK-awk}

SORT=sort		# Could be /bin/sort or /usr/bin/sort

C_FILE=$1; shift
H_FILE=$1; shift

# Must unset, so that RS="" works in gawk 3.0-3.1.1 (possibly earlier too)
# Appears to be a gawk bug, RS="" is not an extension
unset POSIXLY_CORRECT

${AWK} '
	BEGIN{ RS=""; FS="\n" }
	# Ignore comments and blank lines
	/^[ \t]*(;|$)/	{ next }
	/^[^ \t]/ 	{ gsub ("\n", "\034", $0); print }
' "$@" | ${SORT} | ${AWK} '
    function switch_flags (flags,   result)
    {
	flags = " " flags " "
	result = "0"
	for (j = 0; j < n_langs; j++) {
	    regex = " " langs[j] " "
	    gsub ( "+", "\\+", regex )
	    if (flags ~ regex)
		result = result " | " macros[j]
	}
        if (flags ~ " Common ") result = result " | CL_COMMON"
        if (flags ~ " Joined ") result = result " | CL_JOINED"
        if (flags ~ " Separate ") result = result " | CL_SEPARATE"
        if (flags ~ " RejectNegative ") result = result " | CL_REJECT_NEGATIVE"
	sub( "^0 \\| ", "", result )
	return result
    }

    BEGIN {
	FS = "\034"
	n_opts = 0
	n_langs = 0
    }

# Collect the text and flags of each option into an array
    {
	if ($1 == "Language") {
		langs[n_langs] = $2
		n_langs++;
	} else {
		opts[n_opts] = $1
		flags[n_opts] = $2
		n_opts++;
	}
    }

# Dump out an enumeration into a .h file, and an array of options into a
# C file.  Combine the flags of duplicate options.
    END {
	c_file = "'${C_FILE}'"
	h_file = "'${H_FILE}'"
	comma = ","

	print "/* This file is auto-generated by opts.sh.  */\n" > h_file
	for (i = 0; i < n_langs; i++) {
	    macros[i] = "CL_" langs[i]
	    gsub( "[^A-Za-z0-9_]", "X", macros[i] )
	    s = substr("         ", length (macros[i]))
	    print "#define " macros[i] s " (1 << " i ")" >> h_file
	}
	print "\nenum opt_code\n{"			>> h_file

	print "/* This file is auto-generated by opts.sh.  */\n" > c_file
	print "#include \"" h_file "\""			>> c_file
	print "#include \"opts.h\"\n"			>> c_file
	print "const unsigned int cl_options_count = N_OPTS;\n" >> c_file
	print "const struct cl_option cl_options[] =\n{" >> c_file

	for (i = 0; i < n_opts; i++) {
	    while( i + 1 != n_opts && opts[i] == opts[i + 1] ) {
		flags[i + 1] = flags[i] " " flags[i + 1];
		i++;
	    }

	    enum = "OPT_" opts[i]
	    gsub( "[^A-Za-z0-9]", "_", enum)
	    s = substr("                                  ", length (opts[i]))
	    if (i + 1 == n_opts)
		comma = ""

	    printf("  %s,%s/* -%s */\n", enum, s, opts[i]) >> h_file
	    printf("  { \"%s\", %u, %s }%s\n", opts[i], \
		length(opts[i]), switch_flags(flags[i]), comma) >> c_file
	}

	print "  N_OPTS\n};"				>> h_file
	print "};"					>> c_file
    }
'
