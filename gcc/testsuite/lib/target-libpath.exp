# Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GCC; see the file COPYING3.  If not see
# <http://www.gnu.org/licenses/>.

# This file was contributed by John David Anglin (dave.anglin@nrc-cnrc.gc.ca)

# A list of ld library path environment variables that might need to be
# defined.
#
# Some variables represent ABI-specific paths, and if these variables
# aren't defined, the dynamic loader might fall back on a more general
# variable.  We must do the same when trying to read the current setting
# of such a path.  Each element of this list is therefore itself a list:
# the first element of each sublist specifies the name of the variable,
# and the other elements specify fallback alternatives.  We use FOO as a
# shorthand for { FOO }.
set ld_library_path_vars {
    LD_LIBRARY_PATH
    LD_RUN_PATH
    SHLIB_PATH
    { LD_LIBRARYN32_PATH LD_LIBRARY_PATH }
    { LD_LIBRARY64_PATH LD_LIBRARY_PATH }
    { LD_LIBRARY_PATH_32 LD_LIBRARY_PATH }
    { LD_LIBRARY_PATH_64 LD_LIBRARY_PATH }
    DYLD_LIBRARY_PATH
}

# Set up the global orig_FOO_saved variables.  We define this as a function
# to avoid polluting the global namespace with local variables.
proc init_ld_library_path_env_vars { } {
    global ld_library_path_vars

    foreach spec $ld_library_path_vars {
	set var orig_[string tolower [lindex $spec 0]]_saved
	global $var
	set $var 0
    }
}
init_ld_library_path_env_vars
set orig_environment_saved 0
set orig_gcc_exec_prefix_saved 0
set orig_gcc_exec_prefix_checked 0
set ld_library_path_multilib unset

#######################################
# proc set_ld_library_path_env_vars { }
#######################################

proc set_ld_library_path_env_vars { } {
    global ld_library_path
    global orig_environment_saved
    global ld_library_path_vars
    global orig_gcc_exec_prefix_saved
    global orig_gcc_exec_prefix_checked
    global orig_gcc_exec_prefix
    global TEST_GCC_EXEC_PREFIX
    global ld_library_path_multilib
    global env

    # Save the original GCC_EXEC_PREFIX.
    if { $orig_gcc_exec_prefix_checked == 0 } {
	if [info exists env(GCC_EXEC_PREFIX)] {
	    set orig_gcc_exec_prefix "$env(GCC_EXEC_PREFIX)"
	    set orig_gcc_exec_prefix_saved 1
	}
	set orig_gcc_exec_prefix_checked 1
    }

    # Set GCC_EXEC_PREFIX for the compiler under test to pick up files not in
    # the build tree from a specified location (normally the install tree).
    if [info exists TEST_GCC_EXEC_PREFIX] {
	setenv GCC_EXEC_PREFIX "$TEST_GCC_EXEC_PREFIX"
    }

    # Setting the ld library path causes trouble when testing cross-compilers.
    if { [is_remote target] } {
	return
    }

    set ld_library_path_multilib [board_info target multilib_flags]

    foreach spec $ld_library_path_vars {
	set var [lindex $spec 0]
	set lvar [string tolower $var]

	global orig_$lvar
	global orig_${lvar}_saved

	if { $orig_environment_saved == 0 } {
	    if [info exists env($var)] {
		set orig_$lvar [set env($var)]
		set orig_${lvar}_saved 1
	    }
	}
	set value $ld_library_path
	foreach extra $spec {
	    set lextra [string tolower $extra]
	    if [set orig_${lextra}_saved] {
		add_path value [set orig_$lextra]
		break
	    }
	}
	setenv $var $value
    }
    set orig_environment_saved 1
    verbose -log "set_ld_library_path_env_vars: ld_library_path=$ld_library_path"
}

#######################################
# proc restore_ld_library_path_env_vars { }
#######################################

proc restore_ld_library_path_env_vars { } {
    global orig_environment_saved
    global ld_library_path_vars
    global orig_gcc_exec_prefix_saved
    global orig_gcc_exec_prefix
    global env

    if { $orig_gcc_exec_prefix_saved } {
	setenv GCC_EXEC_PREFIX "$orig_gcc_exec_prefix"
    } elseif [info exists env(GCC_EXEC_PREFIX)] {
	unsetenv GCC_EXEC_PREFIX
    }

    if { $orig_environment_saved == 0 } {
	return
    }

    foreach spec $ld_library_path_vars {
	set var [lindex $spec 0]
	set lvar [string tolower $var]

	global orig_$lvar
	global orig_${lvar}_saved

	if [set orig_${lvar}_saved] {
	    setenv $var [set orig_$lvar]
	} elseif [info exists env($var)] {
	    unsetenv $var
	}
    }
}

#######################################
# proc get_shlib_extension { }
#######################################

proc get_shlib_extension { } {
    global shlib_ext

    if { [ istarget *-*-darwin* ] } {
	set shlib_ext "dylib"
    } elseif { [ istarget *-*-cygwin* ] || [ istarget *-*-mingw* ] } {
	set shlib_ext "dll"
    } elseif { [ istarget hppa*-*-hpux* ] } {
	set shlib_ext "sl"
    } else {
	set shlib_ext "so"
    }
    return $shlib_ext
}

# If DIR is not an empty string, add it to the end of variable UPPATH,
# which represents a colon-separated path.
proc add_path { uppath dir } {
    upvar $uppath path

    if { $dir != "" } {
	if { [info exists path] && $path != "" } {
	    append path ":"
	}
	append path $dir
    }
}

# Return the directory that contains the shared libgcc for this multilib,
# or "" if we don't know.
proc find_libgcc_s { compiler } {
    # Remote host testing requires an installed compiler (get_multilibs
    # imposes the same restriction).  It is up to the board file or
    # tester to make sure that the installed compiler's libraries
    # can be found in the library path.
    if { [is_remote host] } {
	return ""
    }
    # The same goes if we can't find the compiler.
    set compiler_path [which [lindex $compiler 0]]
    if { $compiler_path == "" } {
	return ""
    }
    # Run the compiler with the current multilib flags to get the
    # relative multilib directory.
    set subdir [eval exec $compiler [board_info target multilib_flags] \
		    --print-multi-directory]
    # We are only interested in cases where libgcc_s is in the same
    # directory as the compiler itself.
    set dir [file dirname $compiler_path]
    if { $subdir != "." } {
	set dir [file join $dir $subdir]
    }
    if { ![file exists $dir] } {
	return ""
    }
    return $dir
}
