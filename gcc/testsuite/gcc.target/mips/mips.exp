#   Copyright (C) 1997, 2007 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GCC; see the file COPYING3.  If not see
# <http://www.gnu.org/licenses/>.

# GCC testsuite that uses the `dg.exp' driver.

# Exit immediately if this isn't a MIPS target.
if ![istarget mips*-*-*] {
  return
}

# Load support procs.
load_lib gcc-dg.exp

# Find out which target is selected by the default compiler flags.
# Also remember which aspects of the target are forced on the command
# line (as opposed to being overridable defaults).
#
#    $mips_isa:		 the ISA level specified by __mips
#    $mips_isa_rev:	 the ISA revision specified by __mips_isa_rev
#    $mips_arch:	 the architecture specified by _MIPS_ARCH
#    $mips_gp64:	 true if 64-bit output is selected
#    $mips_fp64:	 true if 64-bit FPRs are selected
#    $mips_float:	 "hard" or "soft"
#    $mips_abi:		 the ABI specified by _MIPS_SIM
#
#    $mips_forced_isa:	 true if the command line uses -march=* or -mips*
#    $mips_forced_abi:	 true if the command line uses -mabi=*
#    $mips_forced_regs:  true if the command line uses -mgp* or -mfp*
#    $mips_forced_float: true if the command line uses -mhard/soft-float
#    $mips_forced_be	 true if the command line uses -EB or -meb
#    $mips_forced_le	 true if the command line uses -EL or -mel
#    $mips_forced_gp	 true if the command line forces a particular GP mode
#    $mips_forced_no_er  true if the command line contains -mno-explicit-relocs
proc setup_mips_tests {} {
    global mips_isa
    global mips_isa_rev
    global mips_arch
    global mips_gp64
    global mips_fp64
    global mips_float
    global mips_abi

    global mips_forced_isa
    global mips_forced_abi
    global mips_forced_float
    global mips_forced_be
    global mips_forced_le
    global mips_forced_gp
    global mips_forced_no_er
    global mips_forced_regs

    global compiler_flags
    global tool

    set src dummy[pid].c
    set f [open $src "w"]
    puts $f {
	int isa = __mips;
	#ifdef __mips_isa_rev
	int isa_rev = __mips_isa_rev;
	#else
	int isa_rev = 1;
	#endif
	const char *arch = _MIPS_ARCH;
	#ifdef __mips64
	int gp64 = 1;
	#endif
	#if __mips_fpr==64
	int fp64 = 1;
	#endif
	#ifdef __mips_hard_float
	const char *float = "hard";
	#else
	const char *float = "soft";
	#endif
	#if !defined _MIPS_SIM
	const char *abi = "eabi";
	#elif _MIPS_SIM=_ABIO32
	const char *abi = "32";
	#elif _MIPS_SIM=_ABIO64
	const char *abi = "o64";
	#elif _MIPS_SIM=_ABIN32
	const char *abi = "n32";
	#else
	const char *abi = "64";
	#endif
    }
    close $f
    set output [${tool}_target_compile $src "" preprocess ""]
    file delete $src

    regexp {isa = ([^;]*)} $output dummy mips_isa
    regexp {isa_rev = ([^;]*)} $output dummy mips_isa_rev
    regexp {arch = "([^"]*)} $output dummy mips_arch
    set mips_gp64 [regexp {gp64 = 1} $output]
    set mips_fp64 [regexp {fp64 = 1} $output]
    regexp {float = "([^"]*)} $output dummy mips_float
    regexp {abi = "([^"]*)} $output dummy mips_abi

    set mips_forced_isa [regexp -- {(-mips[1-5][[:>:]]|-mips32*|-mips64*|-march)} $compiler_flags]
    set mips_forced_abi [regexp -- {-mabi} $compiler_flags]
    set mips_forced_regs [regexp -- {(-mgp|-mfp)} $compiler_flags]
    set mips_forced_float [regexp -- {-m(hard|soft)-float} $compiler_flags]
    set mips_forced_be [regexp -- {-(EB|meb)[[:>:]]} $compiler_flags]
    set mips_forced_le [regexp -- {-(EL|mel)[[:>:]]} $compiler_flags]
    set mips_forced_gp [regexp -- {-(G|m(|no-)((extern|local)-sdata|gpopt)|mabicalls|mrtp)} $compiler_flags]
    set mips_forced_no_er [regexp -- {-mno-explicit-relocs} $compiler_flags]
}

# Return true if command-line option FLAG forces 32-bit code.
proc is_gp32_flag {flag} {
    switch -glob -- $flag {
	-msmartmips -
	-mips[12] -
	-mips32* -
	-march=mips32* -
	-mabi=32 -
	-mgp32 { return 1 }
	default { return 0 }
    }
}

# Return true if command-line option FLAG forces 64-bit code.
proc is_gp64_flag {flag} {
    switch -glob -- $flag {
	-mabi=64 -
	-mabi=o64 -
	-mabi=n32 -
	-mgp64 { return 1 }
	default { return 0 }
    }
}

# Like dg-options, but treats certain MIPS-specific options specially:
#
#    -mgp32
#    -march=mips32*
#	Force 32-bit code.  Skip the test if the multilib flags force
#	a 64-bit ABI.
#
#    -mgp64
#	Force 64-bit code.  Also force a 64-bit target architecture
#	if the other flags don't do so.  Skip the test if the multilib
#	flags force a 32-bit ABI or a 32-bit architecture.
#
#    -mfp64
#	Force the use of 64-bit floating-point registers on a 32-bit target.
#	Also force -mhard-float and an architecture that supports such a
#	combination, unless these things are already specified by other
#	parts of the given flags.
#
#    -mabi=*
#	Force a particular ABI.  Skip the test if the multilib flags
#	force a specific ABI or a different register size.
#
#    -march=*
#    -mips*
#	Select the target architecture.  Skip the test if the multilib
#	flags force a different architecture.
#
#    -msoft-float
#    -mhard-float
#	Select the given floating-point mode.  Skip the test if the
#	multilib flags force a different selection.
#
#    -EB
#    -EL
#	Select the given endianness.  Skip the test if the multilib flags
#	force the opposite endianness.
#
#    -G*
#    -m(no-)extern-sdata
#    -m(no-)local-sdata
#    -m(no-)gpopt
#	Select the small-data mode, and -mno-abcialls.  Skip the test if
#	the multilib flags already contain such an option, or specify
#	something that might be incompatible with them.
#
#    -mexplicit-relocs
#	Select explicit relocations.  Skip the test if the multilib flags
#	force -mno-explicit-relocs.
proc dg-mips-options {args} {
    upvar dg-extra-tool-flags extra_tool_flags
    upvar dg-do-what do_what

    global mips_isa
    global mips_isa_rev
    global mips_arch
    global mips_gp64
    global mips_fp64
    global mips_float
    global mips_abi

    global mips_forced_isa
    global mips_forced_abi
    global mips_forced_regs
    global mips_forced_float
    global mips_forced_be
    global mips_forced_le
    global mips_forced_gp
    global mips_forced_no_er

    set flags [lindex $args 1]
    set matches 1

    # First handle the -mgp* options.  Add an architecture option if necessary.
    foreach flag $flags {
	if {$flag == "-mfp64"} {
	    if {!$mips_fp64 && $mips_forced_regs} {
		set matches 0
	    } else {
		if {[lsearch -regexp $flags {^-m(hard|soft)-float$}] < 0} {
		    append flags " -mhard-float"
		}
		if {[lsearch -regexp $flags {^(-mips|-march)}] < 0} {
		    append flags " -mips32r2"
		}
	    }
	}
    }
    foreach flag $flags {
	if {[is_gp32_flag $flag]
	    && ($mips_gp64
		|| ($mips_fp64 && [lsearch $flags -mfp64] < 0)) } {
	    if {$mips_forced_regs || $mips_forced_abi} {
		set matches 0
	    } elseif {[lsearch $flags "-mabi=*"] < 0} {
		append flags " -mabi=32"
	    }
	} elseif {[is_gp64_flag $flag] && !$mips_gp64} {
	    if {$mips_forced_regs || $mips_forced_abi} {
		set matches 0
	    } else {
	    	if {[lsearch $flags "-mabi=*"] < 0} {
		    append flags " -mabi=o64"
		}
		if {[lsearch -regexp $flags {^(-mips|-march)}] < 0} {
		    append flags " -mips3"
		}
	    }
	}
    }
    # Handle the other options.
    foreach flag $flags {
	if {[regexp -- {^-mabi=(.*)} $flag dummy abi]} {
	    if {$abi != $mips_abi && $mips_forced_abi} {
		set matches 0
	    }
	} elseif {[regexp -- {^-march=(.*)} $flag dummy arch]} {
	    if {$arch != $mips_arch && $mips_forced_isa} {
		set matches 0
	    }
	} elseif {[regexp -- {^-mips(.*)} $flag dummy isa]} {
	    if {![regexp {(.*)r(.*)} $isa dummy isa isa_rev]} {
		set isa_rev 1
	    }
	    if {($isa != $mips_isa || $isa_rev != $mips_isa_rev)
		&& $mips_forced_isa} {
		set matches 0
	    }
	} elseif {[regexp -- {^-m(hard|soft)-float} $flag dummy float]} {
	    if {$mips_float != $float && $mips_forced_float} {
		set matches 0
	    }
	} elseif {[regexp -- {^-(EB|meb)$} $flag]} {
	    if {$mips_forced_le} {
		set matches 0
	    }
	} elseif {[regexp -- {^-(EL|mel)$} $flag]} {
	    if {$mips_forced_be} {
		set matches 0
	    }
	} elseif {[regexp -- {^-(G|m(|no-)((extern|local)-sdata|gpopt))} $flag]} {
	    append flags " -mno-abicalls"
	    if {$mips_forced_gp} {
		set matches 0
	    }
	} elseif {[regexp -- {^-mexplicit-relocs$} $flag]} {
	    if {$mips_forced_no_er} {
		set matches 0
	    }
	}
    }
    if {$matches} {
	append extra_tool_flags " " $flags
    } else {
	set do_what [list [lindex $do_what 0] "N" "P"]
    }
}

setup_mips_tests

dg-init
dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c]] "" \
    "-DMIPS16=__attribute__((mips16)) -DNOMIPS16=__attribute__((nomips16))"
dg-finish
