<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html
          PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
   <meta name="AUTHOR" content="bkoz@gcc.gnu.org (Benjamin Kosnik), Felix Natter" />
   <meta name="KEYWORDS" content="C++, libstdc++, API, backward, compatibility" />
   <meta name="DESCRIPTION" content="Backwards Compatibility" />
   <meta name="GENERATOR" content="emacs and ten fingers" />
   <title>Backwards Compatibility</title>
<link rel="StyleSheet" href="lib3styles.css" type="text/css" />
<link rel="Start" href="documentation.html" type="text/html"
  title="GNU C++ Standard Library" />
<link rel="Copyright" href="17_intro/license.html" type="text/html" />
</head>
<body>

<h1 class="centered"><a name="top">Backwards Compatibility</a></h1>

<p class="fineprint"><em>
   The latest version of this document is always available at
   <a href="http://gcc.gnu.org/onlinedocs/libstdc++/17_intro/backwards_compatibility.html">
   http://gcc.gnu.org/onlinedocs/libstdc++/17_intro/backwards_compatibility.html</a>.
</em></p>

<p><em>
   To the <a href="http://gcc.gnu.org/libstdc++/">libstdc++ homepage</a>.
</em></p>

<!-- ####################################################### -->
<hr />
<h3 class="left">
  <a name="v1">First.</a>
</h3>

<p> The first generation GNU C++ library was called libg++.  It was a
separate GNU project, although reliably paired with GCC. Rumors imply
that it had a working relationship with at least two kinds of
dinosaur.
</p>

<p>Known Issues include many of the limitations of its immediate ancestor.</p> 

<p>Portability notes and known implementation limitations are as follows.</p>

<h5>No <code>ios_base</code></h5>

<p> At least some older implementations don't have <code>std::ios_base</code>, so you should use <code>std::ios::badbit</code>, <code>std::ios::failbit</code> and <code>std::ios::eofbit</code> and <code>std::ios::goodbit</code>.
</p>

<h5>No <code>cout</code> in <code>ostream.h</code>, no <code>cin</code> in <code>istream.h</code></h5>

<p>
	In earlier versions of the standard,
	<tt>&lt;fstream.h&gt;</tt>,
	<tt>&lt;ostream.h&gt;</tt>
	and <tt>&lt;istream.h&gt;</tt>
	used to define
	<code>cout</code>, <code>cin</code> and so on. ISO C++ specifies that one needs to include
	<tt>&lt;iostream&gt;</tt>
	explicitly to get the required definitions.
 </p>
<p> Some include adjustment may be required.</p>


<p>This project is no longer maintained or supported, and the sources
archived.  The code is considered replaced and rewritten.
</p>

<hr />
<h3 class="left">
  <a name="v2">Second.</a>
</h3>
<p> The second generation GNU C++ library was called libstdc++, or
libstdc++-v2. It spans the time between libg++ and pre-ISO C++
standardization and is usually associated with the following GCC
releases: egcs 1.x, gcc 2.95, and gcc 2.96.
</p>

<p> The STL portions of this library are based on SGI/HP STL release 3.11.
</p>

<p>Portability notes and known implementation limitations are as follows.</p>

<h5>Namespace <code>std::</code> not supported</h5>

<p>
      Some care is required to support C++ compiler and or library
      implementation that do not have the standard library in
      <code>namespace std</code>.
    </p>
<p>
   The following sections list some possible solutions to support compilers
   that cannot ignore <code>std::</code>-qualified names.
 </p>

<p> First, see if the compiler has a flag for this. Namespace
      back-portability-issues are generally not a problem for g++
      compilers that do not have libstdc++ in <code>std::</code>, as
      the compilers use <code>-fno-honor-std</code> (ignore
      <code>std::</code>, <code>:: = std::</code>) by default. That
      is, the responsibility for enabling or disabling
      <code>std::</code> is on the user; the maintainer does not have
      to care about it. This probably applies to some other compilers
      as well.
    </p>

<p>Second, experiment with a variety of pre-processor tricks.</p>

<p> By defining <code>std</code> as a macro, fully-qualified namespace calls become global. Volia. </p>
	      
<pre>
#ifdef WICKEDLY_OLD_COMPILER
# define std
#endif
</pre>
(thanks to Juergen Heinzl who posted this solution on gnu.gcc.help)

<p>Another pre-processor based approach is to define a
macro <code>NAMESPACE_STD</code>, which is defined to either
&quot;&quot; or &quot;std&quot; based on a compile-type test. On GNU
systems, this can be done with autotools by means of an autoconf test
(see below) for <code>HAVE_NAMESPACE_STD</code>, then using that to
set a value for the <code>NAMESPACE_STD</code> macro.  At that point,
one is able to use <code>NAMESPACE_STD::string</code>, which will
evaluate to <code>std::string</code> or
<code>::string</code> (ie, in the global namespace on systems that do
not put <code>string</code> in <code>std::</code>). </p>

<pre style="background: #c0c0c0">
dnl @synopsis AC_CXX_NAMESPACE_STD
dnl
dnl If the compiler supports namespace std, define
dnl HAVE_NAMESPACE_STD.
dnl
dnl @category Cxx
dnl @author Todd Veldhuizen
dnl @author Luc Maisonobe &lt;luc@spaceroots.org&gt;
dnl @version 2004-02-04
dnl @license AllPermissive
AC_DEFUN([AC_CXX_NAMESPACE_STD], [
  AC_CACHE_CHECK(if g++ supports namespace std,
  ac_cv_cxx_have_std_namespace,
  [AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_COMPILE([#include &lt;iostream&gt; 
                  std::istream&amp; is = std::cin;],,
  ac_cv_cxx_have_std_namespace=yes, ac_cv_cxx_have_std_namespace=no)
  AC_LANG_RESTORE
  ])
  if test "$ac_cv_cxx_have_std_namespace" = yes; then
    AC_DEFINE(HAVE_NAMESPACE_STD,,[Define if g++ supports namespace std. ])
  fi
])
</pre>

<h5>Illegal iterator usage</h5>
<p>
      The following illustrate implementation-allowed illegal iterator
      use, and then correct use.  
</p>

<ul> <li><p>you cannot do
      <code>ostream::operator&lt;&lt;(iterator)</code> to print the
      address of the iterator =&gt; use <code>operator&lt;&lt;
      &amp;*iterator</code> instead
	  </p></li>
<li><p>you cannot clear an iterator's reference
	    (<code>iterator = 0</code>) =&gt; use
	    <code>iterator = iterator_type();</code>
	  </p></li>
<li><p>
<code>if (iterator)</code> won't work any
	    more =&gt; use <code>if (iterator != iterator_type())</code>
	    </p></li>
</ul>

<h5><code>isspace</code> from <tt>&lt;cctype&gt;</tt> is a macro
</h5>

<p> Glibc 2.0.x and 2.1.x define <tt>&lt;ctype.h&gt;</tt>
functionality as macros (isspace, isalpha etc.).    
</p>

<p>
This implementations of libstdc++, however, keep these functions as
macros, and so it is not back-portable to use fully qualified
names. For example:
</p>

<pre> 
#include &lt;cctype&gt; 
int main() { std::isspace('X'); } 
</pre> 

<p>Results in something like this:
</p>

<pre> 
std:: (__ctype_b[(int) ( ( 'X' ) )] &amp; (unsigned short int) _ISspace ) ; 
</pre>


<p> A solution is to modify a header-file so that the compiler tells
<tt>&lt;ctype.h&gt;</tt> to define functions instead of macros:
</p>

<pre>
// This keeps isalnum, et al from being propagated as macros. 
#if __linux__
# define __NO_CTYPE 1
#endif
</pre>

<p>Then, include &lt;ctype.h&gt;
</p>

<p>
Another problem arises if you put a <code>using namespace std;</code>
declaration at the top, and include <tt>&lt;ctype.h&gt;</tt>. This
will result in ambiguities between the definitions in the global
namespace (<tt>&lt;ctype.h&gt;</tt>) and the definitions in namespace
<code>std::</code> (<code>&lt;cctype&gt;</code>).    
</p>

<h5>No <code>vector::at</code>, <code>deque::at</code>, <code>string::at</code></h5>

<p>
      One solution is to add an autoconf-test for this:
</p>
<pre style="background: #c0c0c0">
AC_MSG_CHECKING(for container::at)
AC_TRY_COMPILE(
[
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;string&gt;
	
using namespace std;
],
[
deque&lt;int&gt; test_deque(3);
test_deque.at(2);
vector&lt;int&gt; test_vector(2);
test_vector.at(1);
string test_string(&quot;test_string&quot;);
test_string.at(3);
],
[AC_MSG_RESULT(yes)
AC_DEFINE(HAVE_CONTAINER_AT)],
[AC_MSG_RESULT(no)])
</pre>

<p>
If you are using other (non-GNU) compilers it might be a good idea
to check for <code>string::at</code> separately.
</p>

<h5>No <code>std::char_traits&lt;char&gt;::eof</code></h5>

<p>
Use some kind of autoconf test, plus this:
</p>      
<pre> 
#ifdef HAVE_CHAR_TRAITS
#define CPP_EOF std::char_traits&lt;char&gt;::eof()
#else
#define CPP_EOF EOF
#endif
</pre>

<h5>No <code>string::clear</code></h5>

<p>
      There are two functions for deleting the contents of a string:
      <code>clear</code> and <code>erase</code> (the latter
      returns the string).
</p>
      
<pre>
void 
clear() { _M_mutate(0, this-&gt;size(), 0); }
</pre>
<pre>
basic_string&amp; 
erase(size_type __pos = 0, size_type __n = npos)
{ 
  return this-&gt;replace(_M_check(__pos), _M_fold(__pos, __n),
                          _M_data(), _M_data()); 
}
</pre>

<p>
      Unfortunately, ut <code>clear</code> is not
      implemented in this version, so you should use
      <code>erase</code> (which is probably faster than
      <code>operator=(charT*)</code>).
</p>

<h5>Removal of <code>ostream::form</code> and
<code>istream::scan</code> extensions</h5>

<p> These are no longer supported. Please use
   <a href="#sec-stringstream" title="Using stringstreams">
    stringstreams</a> instead.	
</p>

<h5>No <code>basic_stringbuf</code>, <code>basic_stringstream</code></h5>

<p>
Although the ISO standard 
<code>i/ostringstream</code>-classes are provided, (<tt>&lt;sstream&gt;</tt>), for compatibility with older implementations the pre-ISO <code>i/ostrstream</code> (<tt>&lt;strstream&gt;</tt>) interface is also provided, with these caveats:
</p>

      <div class="itemizedlist"><ul type="disc">
<li><p> <code>strstream</code> is considered to be
	    deprecated
	  </p></li>
<li><p> <code>strstream</code> is limited to
	    <code>char</code>
	  </p></li>
<li><p> with <code>ostringstream</code> you don't
	    have to take care of terminating the string or freeing its
	    memory
	  </p></li>
<li><p> <code>istringstream</code> can be re-filled
	    (clear(); str(input);)
	  </p></li>
</ul></div>
<p>
      You can then use output-stringstreams like this:
</p>
       
<pre>
#ifdef HAVE_SSTREAM
# include &lt;sstream&gt;
#else
# include &lt;strstream&gt;
#endif

#ifdef HAVE_SSTREAM
  std::ostringstream oss;
#else
  std::ostrstream oss;
#endif

oss &lt;&lt; &quot;Name=&quot; &lt;&lt; m_name &lt;&lt; &quot;, number=&quot; &lt;&lt; m_number &lt;&lt; std::endl;
...
#ifndef HAVE_SSTREAM
  oss &lt;&lt; std::ends; // terminate the char*-string
#endif

// str() returns char* for ostrstream and a string for ostringstream
// this also causes ostrstream to think that the buffer's memory
// is yours
m_label.set_text(oss.str());
#ifndef HAVE_SSTREAM
  // let the ostrstream take care of freeing the memory
  oss.freeze(false);
#endif
</pre>

<p>
      Input-stringstreams can be used similarly:
</p>
      
<pre> 
std::string input;
...
#ifdef HAVE_SSTREAM
std::istringstream iss(input);
#else
std::istrstream iss(input.c_str());
#endif

int i;
iss &gt;&gt; i; 
</pre>

<p> One (the only?) restriction is that an istrstream cannot be re-filled:
</p>
      
<pre>
std::istringstream iss(numerator);
iss &gt;&gt; m_num;
// this is not possible with istrstream
iss.clear();
iss.str(denominator);
iss &gt;&gt; m_den;
 </pre>
 
<p>
If you don't care about speed, you can put these conversions in
      a template-function:
</p>      
<pre>
template &lt;class X&gt;
void fromString(const string&amp; input, X&amp; any)
{
#ifdef HAVE_SSTREAM
std::istringstream iss(input);
#else
std::istrstream iss(input.c_str());
#endif
X temp;
iss &gt;&gt; temp;
if (iss.fail())
throw runtime_error(..)
any = temp;
}
</pre>

<p> Another example of using stringstreams is in <a href="../21_strings/howto.html" target="_top">this howto</a>.
</p>

<p> There is additional information in the libstdc++-v2 info files, in
particular &quot;info iostream&quot;.
</p>

<h5>Little or no wide character support</h5>

<h5>No templatized iostreams</h5>

<h5>Thread safety issues</h5>

<p>This project is no longer maintained or supported, and the sources
archived.  The code is considered replaced and rewritten.
</p>


<hr />
<h3 class="left">
  <a name="v3">Third.</a>
</h3>
<p> The third generation GNU C++ library is called libstdc++, or
libstdc++-v3.
</p>

      <p>The subset commonly known as the Standard Template Library
         (chapters 23 through 25, mostly) is adapted from the final release
         of the SGI STL (version 3.3), with extensive changes.
      </p>

      <p>A more formal description of the V3 goals can be found in the
         official <a href="../17_intro/DESIGN">design document</a>.
      </p>

<p>Portability notes and known implementation limitations are as follows.</p>

<h5>Pre-ISO headers moved to backwards or removed</h5>

<p> The pre-ISO C++ headers
      (<code>iostream.h</code>, <code>defalloc.h</code> etc.) are
      available, unlike previous libstdc++ versions, but inclusion
      generates a warning that you are using deprecated headers.
</p>

    <p>This compatibility layer is constructed by including the
    standard C++ headers, and injecting any items in
    <code>std::</code> into the global namespace.
   </p>
   <p>For those of you new to ISO C++ (welcome, time travelers!), no,
      that isn't a typo. Yes, the headers really have new names.
      Marshall Cline's C++ FAQ Lite has a good explanation in <a
      href="http://www.parashift.com/c++-faq-lite/coding-standards.html#faq-27.4">item
      [27.4]</a>.
   </p>

<p> Some include adjustment may be required. What follows is an
autoconf test that defines <code>PRE_STDCXX_HEADERS</code> when they
exist.</p>

<pre style="background: #c0c0c0">
# AC_HEADER_PRE_STDCXX
AC_DEFUN([AC_HEADER_PRE_STDCXX], [
  AC_CACHE_CHECK(for pre-ISO C++ include files,
  ac_cv_cxx_pre_stdcxx,
  [AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  ac_save_CXXFLAGS="$CXXFLAGS"
  CXXFLAGS="$CXXFLAGS -Wno-deprecated"	

  # Omit defalloc.h, as compilation with newer compilers is problematic.
  AC_TRY_COMPILE([
  #include &lt;new.h&gt;
  #include &lt;iterator.h&gt;
  #include &lt;alloc.h&gt;
  #include &lt;set.h&gt;
  #include &lt;hashtable.h&gt;
  #include &lt;hash_set.h&gt;
  #include &lt;fstream.h&gt;
  #include &lt;tempbuf.h&gt;
  #include &lt;istream.h&gt;
  #include &lt;bvector.h&gt;
  #include &lt;stack.h&gt;
  #include &lt;rope.h&gt;
  #include &lt;complex.h&gt;
  #include &lt;ostream.h&gt;
  #include &lt;heap.h&gt;
  #include &lt;iostream.h&gt;
  #include &lt;function.h&gt;
  #include &lt;multimap.h&gt;
  #include &lt;pair.h&gt;
  #include &lt;stream.h&gt;
  #include &lt;iomanip.h&gt;
  #include &lt;slist.h&gt;
  #include &lt;tree.h&gt;
  #include &lt;vector.h&gt;
  #include &lt;deque.h&gt;
  #include &lt;multiset.h&gt;
  #include &lt;list.h&gt;
  #include &lt;map.h&gt;
  #include &lt;algobase.h&gt;
  #include &lt;hash_map.h&gt;
  #include &lt;algo.h&gt;
  #include &lt;queue.h&gt;
  #include &lt;streambuf.h&gt;
  ],,
  ac_cv_cxx_pre_stdcxx=yes, ac_cv_cxx_pre_stdcxx=no)
  CXXFLAGS="$ac_save_CXXFLAGS"
  AC_LANG_RESTORE
  ])
  if test "$ac_cv_cxx_pre_stdcxx" = yes; then
    AC_DEFINE(PRE_STDCXX_HEADERS,,[Define if pre-ISO C++ header files are present. ])
  fi
])
</pre>

<p>Porting between pre-ISO headers and ISO headers is simple: headers
like &lt;vector.h&gt; can be replaced with &lt;vector&gt; and a using
directive <code>using namespace std;</code> can be put at the global
scope. This should be enough to get this code compiling, assuming the
other usage is correct.
</p>

<h5>Extension headers hash_map, hash_set moved to ext or backwards</h5>

<p> Header files <code>hash_map</code> and <code>hash_set</code> moved
to <code>ext/hash_map</code> and <code>ext/hash_set</code>,
respectively. At the same time, all types in these files are enclosed
in <code>namespace __gnu_cxx</code>. Later versions move deprecate
these files, and suggest using TR1's <code>unordered_map</code>
and <code>unordered_set</code> instead.
</p>

<p>The following autoconf tests check for working HP/SGI hash containers.
</p>

<pre style="background: #c0c0c0">
# AC_HEADER_EXT_HASH_MAP
AC_DEFUN([AC_HEADER_EXT_HASH_MAP], [
  AC_CACHE_CHECK(for ext/hash_map,
  ac_cv_cxx_ext_hash_map,
  [AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  ac_save_CXXFLAGS="$CXXFLAGS"
  CXXFLAGS="$CXXFLAGS -Werror"	
  AC_TRY_COMPILE([#include &lt;ext/hash_map&gt;], [using __gnu_cxx::hash_map;],
  ac_cv_cxx_ext_hash_map=yes, ac_cv_cxx_ext_hash_map=no)
  CXXFLAGS="$ac_save_CXXFLAGS"
  AC_LANG_RESTORE
  ])
  if test "$ac_cv_cxx_ext_hash_map" = yes; then
    AC_DEFINE(HAVE_EXT_HASH_MAP,,[Define if ext/hash_map is present. ])
  fi
])
</pre>

<pre style="background: #c0c0c0">
# AC_HEADER_EXT_HASH_SET
AC_DEFUN([AC_HEADER_EXT_HASH_SET], [
  AC_CACHE_CHECK(for ext/hash_set,
  ac_cv_cxx_ext_hash_set,
  [AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  ac_save_CXXFLAGS="$CXXFLAGS"
  CXXFLAGS="$CXXFLAGS -Werror"	
  AC_TRY_COMPILE([#include &lt;ext/hash_set&gt;], [using __gnu_cxx::hash_set;],
  ac_cv_cxx_ext_hash_set=yes, ac_cv_cxx_ext_hash_set=no)
  CXXFLAGS="$ac_save_CXXFLAGS"
  AC_LANG_RESTORE
  ])
  if test "$ac_cv_cxx_ext_hash_set" = yes; then
    AC_DEFINE(HAVE_EXT_HASH_SET,,[Define if ext/hash_set is present. ])
  fi
])
</pre>


<h5>
No <code>ios::nocreate/ios::noreplace</code>.
</h5>

<p> The existence of <code>ios::nocreate</code> being used for
input-streams has been confirmed, most probably because the author
thought it would be more correct to specify nocreate explicitly.  So
it can be left out for input-streams.
</p>

<p>For output streams, &quot;nocreate&quot; is probably the default,
unless you specify <code>std::ios::trunc</code> ? To be safe, you can
open the file for reading, check if it has been opened, and then
decide whether you want to create/replace or not. To my knowledge,
even older implementations support <code>app</code>, <code>ate</code>
and <code>trunc</code> (except for <code>app</code> ?).
</p>


<h5>
No <code>stream::attach(int fd)</code>
</h5>

<p>
      Phil Edwards writes: It was considered and rejected for the ISO
      standard.  Not all environments use file descriptors.  Of those
      that do, not all of them use integers to represent them.
    </p>  

<p>
      For a portable solution (among systems which use
      filedescriptors), you need to implement a subclass of
      <code>std::streambuf</code> (or
      <code>std::basic_streambuf&lt;..&gt;</code>) which opens a file
      given a descriptor, and then pass an instance of this to the
      stream-constructor. 
    </p>

<p>
      An extension is available that implements this.
      <code>&lt;ext/stdio_filebuf.h&gt;</code> contains a derived class called
      <a href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/class____gnu__cxx_1_1stdio__filebuf.html"><code>__gnu_cxx::stdio_filebuf</code></a>.
      This class can be constructed from a C <code>FILE*</code> or a file
      descriptor, and provides the <code>fd()</code> function.
    </p>

<p>
 For another example of this, refer to
      <a href="http://www.josuttis.com/cppcode/fdstream.html" target="_top">fdstream example</a> 
      by Nicolai Josuttis.
</p>

<h5>
Support for C++98 dialect.
</h5>

<p>Check for complete library coverage of the C++1998/2003 standard.
</p>

<pre style="background: #c0c0c0">

# AC_HEADER_STDCXX_98
AC_DEFUN([AC_HEADER_STDCXX_98], [
  AC_CACHE_CHECK(for ISO C++ 98 include files,
  ac_cv_cxx_stdcxx_98,
  [AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_COMPILE([
    #include &lt;cassert&gt;
    #include &lt;cctype&gt;
    #include &lt;cerrno&gt;
    #include &lt;cfloat&gt;
    #include &lt;ciso646&gt;
    #include &lt;climits&gt;
    #include &lt;clocale&gt;
    #include &lt;cmath&gt;
    #include &lt;csetjmp&gt;
    #include &lt;csignal&gt;
    #include &lt;cstdarg&gt;
    #include &lt;cstddef&gt;
    #include &lt;cstdio&gt;
    #include &lt;cstdlib&gt;
    #include &lt;cstring&gt;
    #include &lt;ctime&gt;

    #include &lt;algorithm&gt;
    #include &lt;bitset&gt;
    #include &lt;complex&gt;
    #include &lt;deque&gt;
    #include &lt;exception&gt;
    #include &lt;fstream&gt;
    #include &lt;functional&gt;
    #include &lt;iomanip&gt;
    #include &lt;ios&gt;
    #include &lt;iosfwd&gt;
    #include &lt;iostream&gt;
    #include &lt;istream&gt;
    #include &lt;iterator&gt;
    #include &lt;limits&gt;
    #include &lt;list&gt;
    #include &lt;locale&gt;
    #include &lt;map&gt;
    #include &lt;memory&gt;
    #include &lt;new&gt;
    #include &lt;numeric&gt;
    #include &lt;ostream&gt;
    #include &lt;queue&gt;
    #include &lt;set&gt;
    #include &lt;sstream&gt;
    #include &lt;stack&gt;
    #include &lt;stdexcept&gt;
    #include &lt;streambuf&gt;
    #include &lt;string&gt;
    #include &lt;typeinfo&gt;
    #include &lt;utility&gt;
    #include &lt;valarray&gt;
    #include &lt;vector&gt;
  ],,
  ac_cv_cxx_stdcxx_98=yes, ac_cv_cxx_stdcxx_98=no)
  AC_LANG_RESTORE
  ])
  if test "$ac_cv_cxx_stdcxx_98" = yes; then
    AC_DEFINE(STDCXX_98_HEADERS,,[Define if ISO C++ 1998 header files are present. ])
  fi
])
</pre>


<h5>
Support for C++TR1 dialect.
</h5>

<p>Check for library coverage of the TR1 standard.
</p>

<pre style="background: #c0c0c0">

# AC_HEADER_STDCXX_TR1
AC_DEFUN([AC_HEADER_STDCXX_TR1], [
  AC_CACHE_CHECK(for ISO C++ TR1 include files,
  ac_cv_cxx_stdcxx_tr1,
  [AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_COMPILE([
  #include &lt;tr1/array&gt;
  #include &lt;tr1/ccomplex&gt;
  #include &lt;tr1/cctype&gt;
  #include &lt;tr1/cfenv&gt;
  #include &lt;tr1/cfloat&gt;
  #include &lt;tr1/cinttypes&gt;
  #include &lt;tr1/climits&gt;
  #include &lt;tr1/cmath&gt;
  #include &lt;tr1/complex&gt;
  #include &lt;tr1/cstdarg&gt;
  #include &lt;tr1/cstdbool&gt;
  #include &lt;tr1/cstdint&gt;
  #include &lt;tr1/cstdio&gt;
  #include &lt;tr1/cstdlib&gt;
  #include &lt;tr1/ctgmath&gt;
  #include &lt;tr1/ctime&gt;
  #include &lt;tr1/cwchar&gt;
  #include &lt;tr1/cwctype&gt;
  #include &lt;tr1/functional&gt;
  #include &lt;tr1/memory&gt;
  #include &lt;tr1/random&gt;
  #include &lt;tr1/regex&gt;
  #include &lt;tr1/tuple&gt;
  #include &lt;tr1/type_traits&gt;
  #include &lt;tr1/unordered_set&gt;
  #include &lt;tr1/unordered_map&gt;
  #include &lt;tr1/utility&gt;
  ],,
  ac_cv_cxx_stdcxx_tr1=yes, ac_cv_cxx_stdcxx_tr1=no)
  AC_LANG_RESTORE
  ])
  if test "$ac_cv_cxx_stdcxx_tr1" = yes; then
    AC_DEFINE(STDCXX_TR1_HEADERS,,[Define if ISO C++ TR1 header files are present. ])
  fi
])
</pre>

<p>An alternative is to check just for specific TR1 includes, such as &lt;unordered_map&gt; and &lt;unordered_set&gt;.
</p>

<pre style="background: #c0c0c0">
# AC_HEADER_TR1_UNORDERED_MAP
AC_DEFUN([AC_HEADER_TR1_UNORDERED_MAP], [
  AC_CACHE_CHECK(for tr1/unordered_map,
  ac_cv_cxx_tr1_unordered_map,
  [AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_COMPILE([#include &lt;tr1/unordered_map&gt;], [using std::tr1::unordered_map;],
  ac_cv_cxx_tr1_unordered_map=yes, ac_cv_cxx_tr1_unordered_map=no)
  AC_LANG_RESTORE
  ])
  if test "$ac_cv_cxx_tr1_unordered_map" = yes; then
    AC_DEFINE(HAVE_TR1_UNORDERED_MAP,,[Define if tr1/unordered_map is present. ])
  fi
])
</pre>

<pre style="background: #c0c0c0">
# AC_HEADER_TR1_UNORDERED_SET
AC_DEFUN([AC_HEADER_TR1_UNORDERED_SET], [
  AC_CACHE_CHECK(for tr1/unordered_set,
  ac_cv_cxx_tr1_unordered_set,
  [AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_COMPILE([#include &lt;tr1/unordered_set&gt;], [using std::tr1::unordered_set;],
  ac_cv_cxx_tr1_unordered_set=yes, ac_cv_cxx_tr1_unordered_set=no)
  AC_LANG_RESTORE
  ])
  if test "$ac_cv_cxx_tr1_unordered_set" = yes; then
    AC_DEFINE(HAVE_TR1_UNORDERED_SET,,[Define if tr1/unordered_set is present. ])
  fi
])
</pre>



<h5>
Support for C++0x dialect.
</h5>

<p>Check for baseline language coverage in the compiler for the C++0xstandard.
</p>

<pre style="background: #c0c0c0">
# AC_COMPILE_STDCXX_OX
AC_DEFUN([AC_COMPILE_STDCXX_0X], [
  AC_CACHE_CHECK(if g++ supports C++0x features without additional flags,
  ac_cv_cxx_compile_cxx0x_native,
  [AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  AC_TRY_COMPILE([
  template &lt;typename T&gt;
    struct check 
    {
      static_assert(sizeof(int) &lt;= sizeof(T), "not big enough");
    };

    typedef check&lt;check&lt;bool&gt;&gt; right_angle_brackets;

    int a;
    decltype(a) b;

    typedef check&lt;int&gt; check_type;
    check_type c;
    check_type&amp;&amp; cr = c;],,
  ac_cv_cxx_compile_cxx0x_native=yes, ac_cv_cxx_compile_cxx0x_native=no)
  AC_LANG_RESTORE
  ])

  AC_CACHE_CHECK(if g++ supports C++0x features with -std=c++0x,
  ac_cv_cxx_compile_cxx0x_cxx,
  [AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  ac_save_CXXFLAGS="$CXXFLAGS"
  CXXFLAGS="$CXXFLAGS -std=c++0x"	
  AC_TRY_COMPILE([
  template &lt;typename T&gt;
    struct check 
    {
      static_assert(sizeof(int) &lt;= sizeof(T), "not big enough");
    };

    typedef check&lt;check&lt;bool&gt;&gt; right_angle_brackets;

    int a;
    decltype(a) b;

    typedef check&lt;int&gt; check_type;
    check_type c;
    check_type&amp;&amp; cr = c;],,
  ac_cv_cxx_compile_cxx0x_cxx=yes, ac_cv_cxx_compile_cxx0x_cxx=no)
  CXXFLAGS="$ac_save_CXXFLAGS"
  AC_LANG_RESTORE
  ])

  AC_CACHE_CHECK(if g++ supports C++0x features with -std=gnu++0x,
  ac_cv_cxx_compile_cxx0x_gxx,
  [AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  ac_save_CXXFLAGS="$CXXFLAGS"
  CXXFLAGS="$CXXFLAGS -std=gnu++0x"	
  AC_TRY_COMPILE([
  template &lt;typename T&gt;
    struct check 
    {
      static_assert(sizeof(int) &lt;= sizeof(T), "not big enough");
    };

    typedef check&lt;check&lt;bool&gt;&gt; right_angle_brackets;

    int a;
    decltype(a) b;

    typedef check&lt;int&gt; check_type;
    check_type c;
    check_type&amp;&amp; cr = c;],,
  ac_cv_cxx_compile_cxx0x_gxx=yes, ac_cv_cxx_compile_cxx0x_gxx=no)
  CXXFLAGS="$ac_save_CXXFLAGS"
  AC_LANG_RESTORE
  ])

  if test "$ac_cv_cxx_compile_cxx0x_native" = yes || 
     test "$ac_cv_cxx_compile_cxx0x_cxx" = yes || 
     test "$ac_cv_cxx_compile_cxx0x_gxx" = yes; then
    AC_DEFINE(HAVE_STDCXX_0X,,[Define if g++ supports C++0x features. ])
  fi
])
</pre>


<p>Check for library coverage of the C++0xstandard.
</p>

<pre style="background: #c0c0c0">

# AC_HEADER_STDCXX_0X
AC_DEFUN([AC_HEADER_STDCXX_0X], [
  AC_CACHE_CHECK(for ISO C++ 0x include files,
  ac_cv_cxx_stdcxx_0x,
  [AC_REQUIRE([AC_COMPILE_STDCXX_0X])
  AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  ac_save_CXXFLAGS="$CXXFLAGS"
  CXXFLAGS="$CXXFLAGS -std=gnu++0x"	

  AC_TRY_COMPILE([
    #include &lt;cassert&gt;
    #include &lt;ccomplex&gt;
    #include &lt;cctype&gt;
    #include &lt;cerrno&gt;
    #include &lt;cfenv&gt;
    #include &lt;cfloat&gt;
    #include &lt;cinttypes&gt;
    #include &lt;ciso646&gt;
    #include &lt;climits&gt;
    #include &lt;clocale&gt;
    #include &lt;cmath&gt;
    #include &lt;csetjmp&gt;
    #include &lt;csignal&gt;
    #include &lt;cstdarg&gt;
    #include &lt;cstdbool&gt;
    #include &lt;cstddef&gt;
    #include &lt;cstdint&gt;
    #include &lt;cstdio&gt;
    #include &lt;cstdlib&gt;
    #include &lt;cstring&gt;
    #include &lt;ctgmath&gt;
    #include &lt;ctime&gt;
    #include &lt;cwchar&gt;
    #include &lt;cwctype&gt;

    #include &lt;algorithm&gt;
    #include &lt;array&gt;
    #include &lt;bitset&gt;
    #include &lt;complex&gt;
    #include &lt;deque&gt;
    #include &lt;exception&gt;
    #include &lt;fstream&gt;
    #include &lt;functional&gt;
    #include &lt;iomanip&gt;
    #include &lt;ios&gt;
    #include &lt;iosfwd&gt;
    #include &lt;iostream&gt;
    #include &lt;istream&gt;
    #include &lt;iterator&gt;
    #include &lt;limits&gt;
    #include &lt;list&gt;
    #include &lt;locale&gt;
    #include &lt;map&gt;
    #include &lt;memory&gt;
    #include &lt;new&gt;
    #include &lt;numeric&gt;
    #include &lt;ostream&gt;
    #include &lt;queue&gt;
    #include &lt;random&gt;
    #include &lt;regex&gt;
    #include &lt;set&gt;
    #include &lt;sstream&gt;
    #include &lt;stack&gt;
    #include &lt;stdexcept&gt;
    #include &lt;streambuf&gt;
    #include &lt;string&gt;
    #include &lt;tuple&gt;
    #include &lt;typeinfo&gt;
    #include &lt;type_traits&gt;
    #include &lt;unordered_map&gt;
    #include &lt;unordered_set&gt;
    #include &lt;utility&gt;
    #include &lt;valarray&gt;
    #include &lt;vector&gt;
  ],,
  ac_cv_cxx_stdcxx_0x=yes, ac_cv_cxx_stdcxx_0x=no)
  AC_LANG_RESTORE
  CXXFLAGS="$ac_save_CXXFLAGS"
  ])
  if test "$ac_cv_cxx_stdcxx_0x" = yes; then
    AC_DEFINE(STDCXX_0X_HEADERS,,[Define if ISO C++ 0x header files are present. ])
  fi
])
</pre>

<p>As is the case for TR1 support, these autoconf macros can be made for a finer-grained, per-header-file check. For &lt;unordered_map&gt;
</p>

<pre style="background: #c0c0c0">

# AC_HEADER_UNORDERED_MAP
AC_DEFUN([AC_HEADER_UNORDERED_MAP], [
  AC_CACHE_CHECK(for unordered_map,
  ac_cv_cxx_unordered_map,
  [AC_REQUIRE([AC_COMPILE_STDCXX_0X])
  AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  ac_save_CXXFLAGS="$CXXFLAGS"
  CXXFLAGS="$CXXFLAGS -std=gnu++0x"	
  AC_TRY_COMPILE([#include &lt;unordered_map&gt;], [using std::unordered_map;],
  ac_cv_cxx_unordered_map=yes, ac_cv_cxx_unordered_map=no)
  CXXFLAGS="$ac_save_CXXFLAGS"
  AC_LANG_RESTORE
  ])
  if test "$ac_cv_cxx_unordered_map" = yes; then
    AC_DEFINE(HAVE_UNORDERED_MAP,,[Define if unordered_map is present. ])
  fi
])
</pre>

<pre style="background: #c0c0c0">
# AC_HEADER_UNORDERED_SET
AC_DEFUN([AC_HEADER_UNORDERED_SET], [
  AC_CACHE_CHECK(for unordered_set,
  ac_cv_cxx_unordered_set,
  [AC_REQUIRE([AC_COMPILE_STDCXX_0X])
  AC_LANG_SAVE
  AC_LANG_CPLUSPLUS
  ac_save_CXXFLAGS="$CXXFLAGS"
  CXXFLAGS="$CXXFLAGS -std=gnu++0x"	
  AC_TRY_COMPILE([#include &lt;unordered_set&gt;], [using std::unordered_set;],
  ac_cv_cxx_unordered_set=yes, ac_cv_cxx_unordered_set=no)
  CXXFLAGS="$ac_save_CXXFLAGS"
  AC_LANG_RESTORE
  ])
  if test "$ac_cv_cxx_unordered_set" = yes; then
    AC_DEFINE(HAVE_UNORDERED_SET,,[Define if unordered_set is present. ])
  fi
])
</pre>


<h5>
Container iterator_type is not necessarily container value_type*
</h5>


<hr />
<h3 class="left">
  <a name="v4">Fourth, and future</a>
</h3>

<hr />
<h3 class="left">
  <a name="Links">Links</a>
</h3>

<p>
<a href="http://www.kegel.com/gcc/gcc4.html">Migrating to gcc-4.1</a>, by Dan Kegel.
</p>

<p>
<a href="http://lists.debian.org/debian-gcc/2006/03/msg00405.html">Building the whole Debian archive with GCC 4.1: a summary</a>, by Martin Michlmayr
</p>

<p>
<a href="http://annwm.lbl.gov/~leggett/Atlas/gcc-3.2.html">Migration guide for GCC-3.2</a>
</p>

</body>
</html>

