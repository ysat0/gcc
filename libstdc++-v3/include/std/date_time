// <date_time> -*- C++ -*-

// Copyright (C) 2008 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this library; see the file COPYING.  If not, write to
// the Free Software Foundation, 51 Franklin Street, Fifth Floor,
// Boston, MA 02110-1301, USA.

// As a special exception, you may use this file as part of a free software
// library without restriction.  Specifically, if other files instantiate
// templates or use macros or inline functions from this file, or you compile
// this file and link it with other files to produce an executable, this
// file does not by itself cause the resulting executable to be covered by
// the GNU General Public License.  This exception does not however
// invalidate any other reasons why the executable file might be covered by
// the GNU General Public License.

/** @file date_time
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_DATE_TIME
#define _GLIBCXX_DATE_TIME 1

#pragma GCC system_header

#ifndef __GXX_EXPERIMENTAL_CXX0X__
# include <c++0x_warning.h>
#endif

#include <ctime>

namespace std
{
  // duration types

  /// nanoseconds
  class nanoseconds
  {
  public:
  
    // traits information
    typedef long long tick_type;
    static const tick_type ticks_per_second = 1000L * 1000 * 1000;
    static const tick_type seconds_per_tick = 0;
    static const bool is_subsecond = true;
  
    // construct/copy/destroy
    nanoseconds(long long __ns = 0) : _M_ns(__ns) { }
  
    // modifiers
    template<typename _RhsDuration>
      nanoseconds&
      operator+=(const _RhsDuration& __d);
  
    template<typename _RhsDuration>
      nanoseconds&
      operator-=(const _RhsDuration& __d);
  
    nanoseconds&
    operator*=(long __multiplier);
  
    nanoseconds&
    operator/=(long __divisor);
  
    // observers
    tick_type count() const { return _M_ns; }
  
    // operations
    nanoseconds operator-() const { return nanoseconds(-_M_ns); }
  
  private:
    tick_type _M_ns;
  };
  
  class microseconds;
  class milliseconds;
  class seconds;
  class minutes;
  class hours;
  
  /// timepoint type
  class system_time
  {
  public:
  
    // traits information
    typedef nanoseconds::tick_type tick_type;
    static const tick_type ticks_per_second = nanoseconds::ticks_per_second;
    static const tick_type seconds_per_tick = 0;
    static const bool is_subsecond = true;
  
    // create/copy/destroy
  
    system_time() : _M_sec(0), _M_nsec(0) { }
  
    explicit system_time(time_t __s, nanoseconds __ns = 0)
    : _M_sec(__s), _M_nsec(__ns.count()) { }
  
    time_t
    seconds_since_epoch() const { return _M_sec; }
  
    nanoseconds
    nanoseconds_since_epoch() const
    {
      return nanoseconds(_M_nsec + _M_sec * ticks_per_second);
    }
  
    // comparison functions
  
    bool
    operator==(const system_time& __rhs) const
    {
      const tick_type __ns = _M_nsec + _M_sec * ticks_per_second;
      const tick_type __xns = __rhs._M_nsec + __rhs._M_sec * ticks_per_second;
      return __ns == __xns;
    }
  
    bool
    operator!=(const system_time& __rhs) const
    {
      return !(*this == __rhs);
    }
  
    bool
    operator<(const system_time& __rhs) const
    {
      const tick_type __ns = _M_nsec + _M_sec * ticks_per_second;
      const tick_type __xns = __rhs._M_nsec + __rhs._M_sec * ticks_per_second;
      return __ns < __xns;
    }
  
    bool
    operator<=(const system_time& __rhs) const
    {
      return !(__rhs < *this);
    }
  
    bool
    operator>(const system_time& __rhs) const
    {
      return __rhs < *this;
    }
  
    bool
    operator>=(const system_time& __rhs) const
    {
      return !(*this < __rhs);
    }
  
    // arithmetic functions
    nanoseconds
    operator-(const system_time& __rhs) const
    {
      const tick_type __ns = _M_nsec + _M_sec * ticks_per_second;
      const tick_type __xns = __rhs._M_nsec + __rhs._M_sec * ticks_per_second;
      return nanoseconds(__ns - __xns);
    }
  
    template<typename _Duration>
      system_time
      operator+(const _Duration& __td) const;
  
    template<typename _Duration>
      system_time&
      operator+=(const _Duration& __td);
  
    template<typename _Duration>
      system_time
      operator-(const _Duration& __td) const;
  
    template<typename _Duration>
      system_time&
      operator-=(const _Duration& __td);
  
  public:
    std::time_t _M_sec;
    tick_type _M_nsec;
  };
  
  // non-member functions
  system_time
  get_system_time();
  
  template<typename _Duration>
    system_time
    operator+(const _Duration& __td, const system_time& __rhs);
  
  template<class _LhsDuration, class _RhsDuration>
    bool
    operator==(const _LhsDuration& __lhs, const _RhsDuration& __rhs);
  template<class _LhsDuration, class _RhsDuration>
    bool
    operator!=(const _LhsDuration& __lhs, const _RhsDuration& __rhs);
  
  template<class _LhsDuration, class _RhsDuration>
     bool
     operator<(const _LhsDuration& __lhs, const _RhsDuration& __rhs);
  template<class _LhsDuration, class _RhsDuration>
    bool
    operator<=(const _LhsDuration& __lhs, const _RhsDuration& __rhs);
  template<class _LhsDuration, class _RhsDuration>
    bool
    operator>(const _LhsDuration& __lhs, const _RhsDuration& __rhs);
  template<class _LhsDuration, class _RhsDuration>
    bool
    operator>=(const _LhsDuration& __lhs, const _RhsDuration& __rhs);
  
  template<typename _LhsDuration, typename _RhsDuration>
    struct __finest_duration;
  
  template<class _LhsDuration, class _RhsDuration>
    typename __finest_duration<_LhsDuration, _RhsDuration>::type
    operator+(const _LhsDuration& __lhs, const _RhsDuration& __rhs);
  template<class _LhsDuration, class _RhsDuration>
    typename __finest_duration<_LhsDuration, _RhsDuration>::type
    operator-(const _LhsDuration& __lhs, const _RhsDuration& __rhs);
  
  template<class _Duration>
    _Duration
    operator*(_Duration __lhs, long __rhs);
  template<class _Duration>
    _Duration
    operator*(long __lhs, _Duration __rhs);
  
  template<class _Duration>
    _Duration
    operator/(_Duration __lhs, long __rhs);
}

#endif /* _GLIBCXX_DATE_TIME */
