// Components for manipulating non-owning sequences of objects -*- C++ -*-

// Copyright (C) 2019 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file span
 *  This is a Standard C++ Library header.
 */

//
// P0122 span library
// Contributed by ThePhD
//

#ifndef _GLIBCXX_SPAN
#define _GLIBCXX_SPAN 1

#pragma GCC system_header

#if __cplusplus > 201703L

#include <type_traits>
#include <tuple>
#include <utility>
#include <array>
#include <bits/stl_iterator.h>
#include <bits/range_access.h>

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

// FIXME: they forgot this feature test macro
// get on someone's back about it in Belfast!!!
#define __cpp_lib_span 201911

  inline constexpr size_t dynamic_extent = static_cast<size_t>(-1);

  namespace __detail
  {
    template<typename _Element, typename _ToElement>
      static constexpr inline bool __is_base_derived_safe_convertible_v
	= is_convertible_v<_Element (*)[], _ToElement (*)[]>;

    template<typename _Tp>
      inline constexpr bool __is_std_array_v = false;

    template<typename _Tp, size_t _Num>
      inline constexpr bool
      __is_std_array_v<_GLIBCXX_STD_C::array<_Tp, _Num>> = true;

#ifdef _GLIBCXX_DEBUG
    template<typename _Tp, size_t _Num>
      inline constexpr bool
      __is_std_array_v<std::__debug::array<_Tp, _Num>> = true;
#endif // debug/array

    template<size_t _Extent>
      class __extent_storage
      {
      public:
	constexpr
	__extent_storage() noexcept = default;

	constexpr
	__extent_storage(size_t) noexcept
	{ }

	static constexpr size_t
	_M_extent() noexcept
	{ return _Extent; }
      };

    template<>
      class __extent_storage<static_cast<size_t>(-1)>
      {
      public:
	constexpr
	__extent_storage() noexcept : _M_extent_value(0)
	{ };

	constexpr
	__extent_storage(size_t __extent) noexcept
	: _M_extent_value(__extent)
	{ }

	constexpr size_t
	_M_extent() const noexcept
	{ return this->_M_extent_value; }

      private:
	size_t _M_extent_value;
      };

  } // namespace __detail

  template<typename _Type, size_t _Extent = dynamic_extent>
    class span : private __detail::__extent_storage<_Extent>
    {
    public:
      // member types
      using value_type             = remove_cv_t<_Type>;
      using element_type           = _Type;
      using index_type             = size_t;
      using reference              = element_type&;
      using const_reference        = const element_type&;
      using pointer                = _Type*;
      using const_pointer          = const _Type*;
      using iterator
	= __gnu_cxx::__normal_iterator<pointer, span>;
      using const_iterator
	= __gnu_cxx::__normal_iterator<const_pointer, span>;
      using reverse_iterator       = std::reverse_iterator<iterator>;
      using const_reverse_iterator = std::reverse_iterator<const_iterator>;
      using difference_type        = ptrdiff_t;
      // Official wording has no size_type -- why??
      // using size_type = size_t;

      // member constants
      static inline constexpr size_t extent = _Extent;

    private:
      using __base_t = __detail::__extent_storage<extent>;

    public:
      // constructors

      template <typename _Dummy = _Type,
		enable_if_t<is_same_v<_Dummy, _Type>
		  && (_Extent == dynamic_extent || _Extent == 0)>* = nullptr>
	constexpr
	span() noexcept : __base_t(0), _M_ptr(nullptr)
	{ }

      constexpr
      span(const span&) noexcept = default;

      template<size_t _ArrayExtent,
	enable_if_t<
	  (_Extent == dynamic_extent || _ArrayExtent == _Extent)
	  && __detail::__is_base_derived_safe_convertible_v<
	    remove_pointer_t<decltype(::std::__adl_data(
	      ::std::declval<element_type (&)[_ArrayExtent]>()))>,
	    element_type>>* = nullptr>
	constexpr span(element_type (&__arr)[_ArrayExtent])
	noexcept(noexcept(::std::__adl_data(__arr)))
	: span(::std::__adl_data(__arr), _ArrayExtent)
	{ }

      template<size_t _ArrayExtent,
	enable_if_t<
	  (_Extent == dynamic_extent || _ArrayExtent == _Extent)
	  && __detail::__is_base_derived_safe_convertible_v<
	    remove_pointer_t<decltype(::std::__adl_data(
	      ::std::declval<const array<value_type, _ArrayExtent>&>()))>,
	    element_type>>* = nullptr>
	constexpr
	span(array<value_type, _ArrayExtent>& __arr)
	noexcept(noexcept(::std::__adl_data(__arr)))
	: span(::std::__adl_data(__arr), _ArrayExtent)
	{ }

      template<size_t _ArrayExtent,
	enable_if_t<
	  (_Extent == dynamic_extent || _ArrayExtent == _Extent)
	  && __detail::__is_base_derived_safe_convertible_v<
	    remove_pointer_t<decltype(::std::__adl_data(
	      ::std::declval<const array<value_type, _ArrayExtent>&>()))>,
	    element_type>>* = nullptr>
	constexpr
	span(const array<value_type, _ArrayExtent>& __arr)
	noexcept(noexcept(::std::__adl_data(__arr)))
	: span(::std::__adl_data(__arr), _ArrayExtent)
	{ }

      // NOTE: when the time comes, and P1394 -
      // range constructors for std::span - ships in
      // the standard, delete the #else block and remove
      // the conditional
      // if the paper fails, delete #if block
      // and keep the crappy #else block
      // and then cry that NB comments failed C++20...
      // but maybe for C++23?
#if defined(_GLIBCXX_P1394) && _GLIBCXX_P1394
      template<typename _Range,
	enable_if_t<
	  (_Extent == dynamic_extent)
	  && !is_same_v<remove_cvref_t<_Range>, span>
	  && !__detail::__is_std_array_v<remove_cvref_t<_Range>>
	  && !is_array_v<remove_cvref_t<_Range>>
	  && __detail::__is_base_derived_safe_convertible_v<
	    remove_pointer_t<decltype(
	      ::std::__adl_data(::std::declval<_Range&>())
	      + ::std::__adl_size(::std::declval<_Range&>()))>,
	    element_type>>* = nullptr>
	constexpr
	span(_Range&& __range)
	noexcept(noexcept(::std::__adl_data(__range))
		  && noexcept(::std::__adl_size(__range)))
	: span(::std::__adl_data(__range), ::std::__adl_size(__range))
	{ }

      template<typename _ContiguousIterator, typename _Sentinel,
	enable_if_t<!is_convertible_v<_Sentinel, index_type>
	  && __detail::__is_base_derived_safe_convertible_v<
	    remove_reference_t<typename
	      iterator_traits<_ContiguousIterator>::reference>,
	  element_type>>* = nullptr>
	constexpr
	span(_ContiguousIterator __first, _Sentinel __last)
	: span(::std::move(__first), static_cast<index_type>(__last - __first))
	{ }

      template<typename _ContiguousIterator>
	constexpr
	span(_ContiguousIterator __first, index_type __count)
	noexcept(noexcept(::std::__adl_to_address(__first)))
	: __base_t(__count), _M_ptr(::std::__adl_to_address(__first))
	{ __glibcxx_assert(_Extent == dynamic_extent || __count == _Extent); }

#else

      template<typename _Container,
	enable_if_t<
	  (_Extent == dynamic_extent)
	  && !is_same_v<remove_cvref_t<_Container>, span>
	  && !__detail::__is_std_array_v<remove_cvref_t<_Container>>
	  && !is_array_v<remove_cvref_t<_Container>>
	  && __detail::__is_base_derived_safe_convertible_v<
	    remove_pointer_t<decltype(
	      ::std::__adl_data(::std::declval<_Container&>())
	      + ::std::__adl_size(::std::declval<_Container&>()))>,
	    element_type>>* = nullptr>
	constexpr
	span(_Container& __range)
	noexcept(noexcept(::std::__adl_data(__range))
		  && noexcept(::std::__adl_size(__range)))
	: span(::std::__adl_data(__range), ::std::__adl_size(__range))
	{ }

      template<typename _Container,
	enable_if_t<
	  (_Extent == dynamic_extent)
	  && !is_same_v<remove_cvref_t<_Container>, span>
	  && !__detail::__is_std_array_v<remove_cvref_t<_Container>>
	  && !is_array_v<remove_cvref_t<_Container>>
	  && __detail::__is_base_derived_safe_convertible_v<
	    remove_pointer_t<decltype(
	      ::std::__adl_data(::std::declval<_Container&>())
	      + ::std::__adl_size(::std::declval<_Container&>()))>,
	    element_type>>* = nullptr>
	constexpr span(const _Container& __range)
	noexcept(noexcept(::std::__adl_data(__range))
		  && noexcept(::std::__adl_size(__range)))
	: span(::std::__adl_data(__range), ::std::__adl_size(__range))
	{ }

      constexpr
      span(pointer __first, index_type __count) noexcept
      : __base_t(__count), _M_ptr(static_cast<pointer>(__first))
      { __glibcxx_assert(_Extent == dynamic_extent || __count == _Extent); }

      constexpr
      span(pointer __first, pointer __last) noexcept
      : span(::std::move(__first), static_cast<index_type>(__last - __first))
      { }
#endif // P1394

      // assignment

      constexpr span&
      operator=(const span&) noexcept = default;

      // observers: element access

      constexpr reference
      front() const noexcept
      { return *this->begin(); }

      constexpr reference
      back() const noexcept
      {
	iterator __it = this->end();
	--__it;
	return *__it;
      }

      constexpr reference
      operator[](index_type __idx) const noexcept
      { return *(this->_M_ptr + __idx); }

      constexpr pointer
      data() const noexcept
      { return this->_M_ptr; }

      constexpr index_type
      size() const noexcept
      { return this->__base_t::_M_extent(); }

      constexpr index_type
      size_bytes() const noexcept
      { return this->__base_t::_M_extent() * sizeof(element_type); }

      constexpr bool
      empty() const noexcept
      { return size() == 0; }

      // observers: iterator support
      constexpr iterator
      begin() const noexcept
      { return iterator(this->_M_ptr); }

      constexpr const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_ptr); }

      constexpr iterator
      end() const noexcept
      { return iterator(this->_M_ptr + this->size()); }

      constexpr const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_ptr + this->size()); }

      constexpr reverse_iterator
      rbegin() const noexcept
      { return reverse_iterator(this->end()); }

      constexpr const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->cend()); }

      constexpr reverse_iterator
      rend() const noexcept
      { return reverse_iterator(this->begin()); }

      constexpr const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->cbegin()); }

      // observers: subranges
      template<size_t _Count>
	constexpr span<element_type, _Count>
	first() const
	{
	  __glibcxx_assert(_Count < size());
	  return { this->data(), _Count };
	}

      constexpr span<element_type, dynamic_extent>
      first(index_type __count) const
      {
	__glibcxx_assert(__count < size());
	return { this->data(), __count };
      }

      template<size_t _Count>
	constexpr span<element_type, _Count>
	last() const
	{
	  static_assert(_Count == dynamic_extent ||
			  _Extent == dynamic_extent || _Count <= _Extent,
	    "Count or Extent are dynamic, "
	    "or the Count is less than the static extent");
	  __glibcxx_assert(_Count <= size());
	  return { this->data() + (this->size() - _Count), _Count };
	}

      constexpr span<element_type, dynamic_extent>
      last(index_type __count) const
      {
	__glibcxx_assert(__count < size());
	index_type __offset = (this->size() - __count);
	return { this->data() + __offset, __count };
      }

      template<size_t _Offset, size_t _Count = dynamic_extent>
	constexpr auto
	subspan() const
	{
	  static_assert(_Count == dynamic_extent ||
			  _Extent == dynamic_extent ||
			  (_Offset + _Count) <= _Extent,
	    "Count or Extent are dynamic, "
	    "or the Count + Offset is less than the static extent");
	  constexpr size_t __span_extent =
	    (_Count != dynamic_extent
		? _Count
		: (_Extent != dynamic_extent ? _Extent - _Offset
						    : dynamic_extent));
	  using __span_t = span<element_type, __span_extent>;
	  if constexpr(_Count != dynamic_extent)
	    {
	      __glibcxx_assert((_Offset + _Count) < size());
	    }
	  return __span_t(this->data() + _Offset,
	    (_Count == dynamic_extent ? this->size() - _Offset : _Count));
	}

      constexpr span<element_type, dynamic_extent>
      subspan(index_type __offset, index_type __count = dynamic_extent) const
      {
	return {this->data() + __offset,
	  __count == dynamic_extent ? this->size() - __offset : __count};
      }

      // observers: range helpers

      friend constexpr iterator
      begin(span __sp) noexcept
      { return __sp.begin(); }

      friend constexpr iterator
      end(span __sp) noexcept
      { return __sp.end(); }

    private:
      pointer _M_ptr;
    };

  // deduction guides
  template<typename _Type, size_t _ArrayExtent>
    span(_Type(&)[_ArrayExtent])->span<_Type, _ArrayExtent>;

  template<typename _Type, size_t _ArrayExtent>
    span(array<_Type, _ArrayExtent>&)->span<_Type, _ArrayExtent>;

  template<typename _Type, size_t _ArrayExtent>
    span(const array<_Type, _ArrayExtent>&)
      ->span<const _Type, _ArrayExtent>;

#if defined(_GLIBCXX_P1394) && _GLIBCXX_P1394

  template<typename _ContiguousIterator, typename _Sentinel>
    span(_ContiguousIterator, _Sentinel)
      ->span<remove_reference_t<
	typename iterator_traits<_ContiguousIterator>::reference>>;

  template<typename _Range>
    span(_Range &&)
      ->span<remove_reference_t<typename iterator_traits<decltype(
	::std::__adl_begin(::std::declval<_Range&>()))>::reference>>;

#else

  template<typename _Container>
    span(_Container&)->span<typename _Container::value_type>;

  template<typename _Container>
    span(const _Container&)->span<const typename _Container::value_type>;

#endif // P1394

  template<typename _Type, size_t _Extent>
    span<const byte, _Extent == dynamic_extent
	? dynamic_extent : _Extent * sizeof(_Type)>
    inline as_bytes(span<_Type, _Extent> __sp) noexcept
    {
      return {reinterpret_cast<const byte*>(__sp.data()), __sp.size_bytes()};
    }

  template<typename _Type, size_t _Extent>
    span<byte, _Extent == dynamic_extent
       ? dynamic_extent : _Extent * sizeof(_Type)>
    as_writable_bytes(span<_Type, _Extent> __sp) noexcept
    {
      return {reinterpret_cast<byte*>(__sp.data()), __sp.size_bytes()};
    }

  // tuple helpers
  template<size_t _Index, typename _Type, size_t _Extent>
    constexpr _Type&
    get(span<_Type, _Extent> __sp) noexcept
    {
      static_assert(_Extent != dynamic_extent
	&& (_Extent > 0) && (_Index < _Extent),
	"std::get can only be used with a span of non-dynamic (fixed) extent");
      return __sp[_Index];
    }

  template<typename _Type, size_t _Extent>
    struct tuple_size<span<_Type, _Extent>>
    : public integral_constant<size_t, _Extent>
    {
      static_assert(_Extent != dynamic_extent, "tuple_size can only "
	"be used with a span of non-dynamic (fixed) extent");
    };

  template<size_t _Index, typename _Type, size_t _Extent>
    struct tuple_element<_Index, span<_Type, _Extent>>
    {
      static_assert(_Extent != dynamic_extent, "tuple_size can only "
	"be used with a span of non-dynamic (fixed) extent");
      static_assert(_Index < _Extent, "Index is less than Extent");
      using type = typename span<_Type, _Extent>::element_type;
    };

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif // C++20
#endif // _GLIBCXX_SPAN
