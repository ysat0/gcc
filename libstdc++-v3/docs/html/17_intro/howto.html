<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html
          PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
   <meta name="AUTHOR" content="pme@gcc.gnu.org (Phil Edwards), Benjamin Kosnik, Felix Natter" />
   <meta name="KEYWORDS" content="HOWTO, libstdc++, gcc, g++, libg++, STL" />
   <meta name="DESCRIPTION" content="HOWTO for libstdc++ chapter 17." />
   <meta name="GENERATOR" content="vi and eight fingers" />
   <title>libstdc++ HOWTO:  Chapter 17: Library Introduction</title>
<link rel="StyleSheet" href="../lib3styles.css" type="text/css" />
<link rel="Start" href="../documentation.html" type="text/html"
 title="GNU C++ Standard Library" />
<link rel="Next" href="../18_support/howto.html" type="text/html"
  title="Library Support" />
<link rel="Copyright" href="license.html" type="text/html" />
<link rel="Help" href="../faq/index.html" type="text/html" title="F.A.Q." />
</head>
<body>

<h1 class="centered"><a name="top">Chapter 17:  Library Introduction</a></h1>

<p>Chapter 17 is actually a list of definitions and descriptions used
   in the following chapters of the Standard when describing the actual
   library.  Here, we use &quot;Introduction&quot; as an introduction
   to the <em>GNU implementation of</em> the ISO Standard C++ Library.
</p>


<!-- ####################################################### -->
<hr />
<h1>Contents</h1>
<ul>
   <li><a href="#2.0">Header Files</a></li>
   <li><a href="#3.0">Namespaces</a></li>
   <li><a href="#6">Macros</a></li>
   <li><a href="#5">Implementation specific behavior</a></li>
   <li><a href="#7">Multithreading</a></li>
</ul>

<hr />

<!-- ####################################################### -->

<h2><a name="2.0">Header Files</a></h2>
   <p>The C++ standard specifies the entire set of header files that must be
      available to all hosted implementations.  Actually, the word
      &quot;files&quot; is a misnomer, since the contents of the headers
      don't necessarily have to be in any kind of external file.  The
      only rule is that when one <code>#include</code>'s a header, the
      contents of that header become
      available, no matter how.
   </p>

<p>That said, in practice files are used.</p>

<p> There are two main types of include files: header files related to
a specific version of the ISO C++ standard (called Standard Headers),
and all others (TR1, C++ ABI, and Extensions).</p>

<p>Two dialects of standard headers are supported, corresponding to
the 1998 standard as updated for 2003, and the draft of the upcoming
200x standard.
</p>

<p>C++98/03 include files. These are available in the default compilation mode, ie <code>-std=c++98</code> or <code>-std=gnu++98</code>. 
</p>

<center><table border="1"><caption>C++98 Library Headers</caption>
<tr><td>&lt;algorithm&gt;</td><td>&lt;iomanip&gt;</td><td>&lt;list&gt;</td><td>&lt;ostream&gt;</td><td>&lt;streambuf&gt;</td></tr>
<tr><td>&lt;bitset&gt;</td><td>&lt;ios&gt;</td><td>&lt;locale&gt;</td><td>&lt;queue&gt;</td><td>&lt;string&gt;</td></tr>
<tr><td>&lt;complex&gt;</td><td>&lt;iosfwd&gt;</td><td>&lt;map&gt;</td><td>&lt;set&gt;</td><td>&lt;typeinfo&gt;</td></tr>
<tr><td>&lt;deque&gt;</td><td>&lt;iostream&gt;</td><td>&lt;memory&gt;</td><td>&lt;sstream&gt;</td><td>&lt;utility&gt;</td></tr>
<tr><td>&lt;exception&gt;</td><td>&lt;istream&gt;</td><td>&lt;new&gt;</td><td>&lt;stack&gt;</td><td>&lt;valarray&gt;</td></tr>
<tr><td>&lt;fstream&gt;</td><td>&lt;iterator&gt;</td><td>&lt;numeric&gt;</td><td>&lt;stdexcept&gt;</td><td>&lt;vector&gt;</td></tr>
<tr><td>&lt;functional&gt;</td><td>&lt;limits&gt;</td></tr>
</table></center>

<p></p>

<center><table border="1"><caption>C++98 Headers for C Library Facilities</caption>
<tr><td>&lt;cassert&gt;</td><td>&lt;ciso646&gt;</td><td>&lt;csetjmp&gt;</td><td>&lt;cstdio&gt;</td><td>&lt;ctime&gt;</td></tr>
<tr><td>&lt;cctype&gt;</td><td>&lt;climits&gt;</td><td>&lt;csignal&gt;</td><td>&lt;cstdlib&gt;</td><td>&lt;cwchar&gt;</td></tr>
<tr><td>&lt;cerrno&gt;</td><td>&lt;clocale&gt;</td><td>&lt;cstdarg&gt;</td><td>&lt;cstring&gt;</td><td>&lt;cwctype&gt;</td></tr>
<tr><td>&lt;cfloat&gt;</td><td>&lt;cmath&gt;</td><td>&lt;cstddef&gt;</td></tr>
</table></center>

<p>C++0x include files. These are only available in C++0x compilation mode, ie <code>-std=c++0x</code> or <code>-std=gnu++0x</code>. 
</p>

<center><table border="1"><caption>C++0x Library Headers</caption>
<tr><td>&lt;algorithm&gt;</td><td>&lt;iomanip&gt;</td><td>&lt;locale&gt;</td><td>&lt;regex&gt;</td><td>&lt;tuple&gt;</td></tr>
<tr><td>&lt;array&gt;</td><td>&lt;ios&gt;</td><td>&lt;map&gt;</td><td>&lt;set&gt;</td><td>&lt;typeinfo&gt;</td></tr>
<tr><td>&lt;bitset&gt;</td><td>&lt;iosfwd&gt;</td><td>&lt;memory&gt;</td><td>&lt;sstream&gt;</td><td>&lt;type_traits&gt;</td></tr>
<tr><td>&lt;complex&gt;</td><td>&lt;iostream&gt;</td><td>&lt;new&gt;</td><td>&lt;stack&gt;</td><td>&lt;unordered_map&gt;</td></tr>
<tr><td>&lt;deque&gt;</td><td>&lt;istream&gt;</td><td>&lt;numeric&gt;</td><td>&lt;stdexcept&gt;</td><td>&lt;unordered_set&gt;</td></tr>
<tr><td>&lt;exception&gt;</td><td>&lt;iterator&gt;</td><td>&lt;ostream&gt;</td><td>&lt;streambuf&gt;</td><td>&lt;utility&gt;</td></tr>
<tr><td>&lt;fstream&gt;</td><td>&lt;limits&gt;</td><td>&lt;queue&gt;</td><td>&lt;string&gt;</td><td>&lt;valarray&gt;</td></tr>
<tr><td>&lt;functional&gt;</td><td>&lt;list&gt;</td><td>&lt;random&gt;</td><td>&lt;system_error&gt;</td><td>&lt;vector&gt;</td></tr>
</table></center>

<p></p>

<center><table border="1"><caption>C++0x Headers for C Library Facilities</caption>
<tr><td>&lt;cassert&gt;</td><td>&lt;cfloat&gt;</td><td>&lt;cmath&gt;</td><td>&lt;cstddef&gt;</td><td>&lt;ctgmath&gt;</td></tr>
<tr><td>&lt;ccomplex&gt;</td><td>&lt;cinttypes&gt;</td><td>&lt;csetjmp&gt;</td><td>&lt;cstdint&gt;</td><td>&lt;ctime&gt;</td></tr>
<tr><td>&lt;cctype&gt;</td><td>&lt;ciso646&gt;</td><td>&lt;csignal&gt;</td><td>&lt;cstdio&gt;</td><td>&lt;cuchar&gt;</td></tr>
<tr><td>&lt;cerrno&gt;</td><td>&lt;climits&gt;</td><td>&lt;cstdarg&gt;</td><td>&lt;cstdlib&gt;</td><td>&lt;cwchar&gt;</td></tr>
<tr><td>&lt;cfenv&gt;</td><td>&lt;clocale&gt;</td><td>&lt;cstdbool&gt;</td><td>&lt;cstring&gt;</td><td>&lt;cwctype&gt;</td></tr>
</table></center>


<p>In addition, TR1 includes as:
</p>

<center><table border="1"><caption>TR1 Library Headers</caption>
<tr><td>&lt;tr1/array&gt;</td><td>&lt;tr1/memory&gt;</td><td>&lt;tr1/regex&gt;</td><td>&lt;tr1/type_traits&gt;</td><td>&lt;tr1/unordered_set&gt;</td></tr>
<tr><td>&lt;tr1/complex&gt;</td><td>&lt;tr1/random&gt;</td><td>&lt;tr1/tuple&gt;</td><td>&lt;tr1/unordered_map&gt;</td><td>&lt;tr1/utility&gt;</td></tr>
<tr><td>&lt;tr1/functional&gt;</td></tr>
</table></center>

<p></p>

<center><table border="1"><caption>TR1 Headers for C Library Facilities</caption>
<tr><td>&lt;tr1/cmath&gt;</td><td>&lt;tr1/cfloat&gt;</td><td>&lt;tr1/cstdarg&gt;</td><td>&lt;tr1/cstdio&gt;</td><td>&lt;tr1/ctime&gt;</td></tr>
<tr><td>&lt;tr1/ccomplex&gt;</td><td>&lt;tr1/cinttypes&gt;</td><td>&lt;tr1/cstdbool&gt;</td><td>&lt;tr1/cstdlib&gt;</td><td>&lt;tr1/cwchar&gt;</td></tr>
<tr><td>&lt;tr1/cfenv&gt;</td><td>&lt;tr1/climits&gt;</td><td>&lt;tr1/cstdint&gt;</td><td>&lt;tr1/ctgmath&gt;</td><td>&lt;tr1/cwctype&gt;</td></tr>
</table></center>

<p>Also included are files for the C++ ABI interface:
</p>
<center><table border="1"><caption>C++ ABI Headers</caption>
<tr><td>&lt;cxxabi.h&gt;</td><td>&lt;cxxabi_forced.h&gt;</td></tr>
</table></center>

<p>And a large variety of extensions.
</p>

<center><table border="1"><caption>Extension Headers</caption>
<tr><td>&lt;ext/algorithm&gt;</td><td>&lt;ext/debug_allocator.h&gt;</td><td>&lt;ext/mt_allocator.h&gt;</td><td>&lt;ext/pod_char_traits.h&gt;</td><td>&lt;ext/stdio_sync_filebuf.h&gt;</td></tr>
<tr><td>&lt;ext/array_allocator.h&gt;</td><td>&lt;ext/enc_filebuf.h&gt;</td><td>&lt;ext/new_allocator.h&gt;</td><td>&lt;ext/pool_allocator.h&gt;</td><td>&lt;ext/throw_allocator.h&gt;</td></tr>
<tr><td>&lt;ext/atomicity.h&gt;</td><td>&lt;ext/functional&gt;</td><td>&lt;ext/numeric&gt;</td><td>&lt;ext/rb_tree&gt;</td><td>&lt;ext/typelist.h&gt;</td></tr>
<tr><td>&lt;ext/bitmap_allocator.h&gt;</td><td>&lt;ext/iterator&gt;</td><td>&lt;ext/numeric_traits.h&gt;</td><td>&lt;ext/rope&gt;</td><td>&lt;ext/type_traits.h&gt;</td></tr>
<tr><td>&lt;ext/codecvt_specializations.h&gt;</td><td>&lt;ext/malloc_allocator.h&gt;</td><td>&lt;ext/pb_ds/assoc_container.h&gt;</td><td>&lt;ext/slist&gt;</td><td>&lt;ext/vstring.h&gt;</td></tr>
<tr><td>&lt;ext/concurrence.h&gt;</td><td>&lt;ext/memory&gt;</td><td>&lt;ext/pb_ds/priority_queue.h&gt;</td><td>&lt;ext/stdio_filebuf.h&gt;</td></tr>
</table></center>

<p></p>

<center><table border="1"><caption>Extension Debug Headers</caption>
<tr><td>&lt;debug/bitset&gt;</td><td>&lt;debug/list&gt;</td><td>&lt;debug/set&gt;</td><td>&lt;debug/unordered_map&gt;</td><td>&lt;debug/vector&gt;</td></tr>
<tr><td>&lt;debug/deque&gt;</td><td>&lt;debug/map&gt;</td><td>&lt;debug/string&gt;</td><td>&lt;debug/unordered_set&gt;</td></tr>
</table></center>

<p></p>

<center><table border="1"><caption>Extension Parallel Headers</caption>
<tr><td>&lt;parallel/algorithm&gt;</td><td>&lt;parallel/numeric&gt;</td></tr>
</table></center>

<hr />
<h2><a name="2.1">Recipes for mixing headers</a></h2>

<p> A few simple rules.
</p>

<p>First, mixing different dialects of the standard headers is not
possible. It's an all-or-nothing affair. Thus, code like
</p>

<pre>
#include &lt;array&gt;
#include &lt;functional&gt;
</pre>

<p>Implies C++0x mode. To use the entities in &lt;array&gt;, the C++0x
compilation mode must be used, which implies the C++0x functionality
(and deprecations) in &lt;functional&gt; will be present.
</p>

<p>Second, the other headers can be included with either dialect of
the standard headers, although features and types specific to C++0x
are still only enabled when in C++0x compilation mode. So, to use
rvalue references with <code>__gnu_cxx::vstring</code>, or to use the
debug-mode versions of <code>std::unordered_map</code>, one must use
the <code>std=gnu++0x</code> compiler flag. (Or <code>std=c++0x</code>, of course.)
</p>

<p>A special case of the second rule is the mixing of TR1 and C++0x
facilities. It is possible (although not especially prudent) to
include both the TR1 version and the C++0x version of header in the
same translation unit:
</p>

<pre>
#include &lt;tr1/type_traits&gt;
#include &lt;type_traits&gt;
</pre>

<p> Several parts of C++0x diverge quite substantially from TR1 predecessors.
</p>


<hr />
<h2><a name="2.2">The C Headers and <code>namespace std</code></a></h2>
<p>
	The standard specifies that if one includes the C-style header
	(&lt;math.h&gt; in this case), the symbols will be available
	in the global namespace and perhaps in
	namespace <code>std::</code> (but this is no longer a firm
	requirement.) One the other hand, including the C++-style
	header (&lt;cmath&gt;) guarantees that the entities will be
	found in namespace std and perhaps in the global namespace.
      </p>

<p>
Usage of C++-style headers is recommended, as then
C-linkage names can be disambiguated by explicit qualification, such
as by <code>std::abort</code>. In addition, the C++-style headers can
use function overloading to provide a simpler interface to certain
families of C-functions. For instance in &lt;cmath&gt;, the
function <code>std::sin</code> has overloads for all the builtin
floating-point types. This means that <code>std::sin</code> can be
used uniformly, instead of a combination
of <code>std::sinf</code>, <code>std::sin</code>,
and <code>std::sinl</code>.
</p>

<hr />
<h2><a name="2.3">Precompiled Headers</a></h2>

<p>There are three base header files that are provided. They can be
used to precompile the standard headers and extensions into binary
files that may the be used to speed compiles that use these headers.
</p>


<ul>
<li>stdc++.h
<p>Includes all standard headers. Actual content varies depending on
language dialect.
</p>
</li>

<li>stdtr1c++.h
<p>Includes all of &lt;stdc++.h&gt;, and adds all the TR1 headers.
</p>
</li>

<li>extc++.h
<p>Includes all of &lt;stdtr1c++.h&gt;, and adds all the Extension headers.
</p></li>
</ul>

<p>How to construct a .gch file from one of these base header files.</p>

<p>First, find the include directory for the compiler. One way to do
this is:</p>

<pre>
g++ -v hello.cc

#include &lt;...&gt; search starts here:
 /mnt/share/bld/H-x86-gcc.20071201/include/c++/4.3.0
...
End of search list.
</pre>


<p>Then, create a precompiled header file with the same flags that
will be used to compile other projects.</p>

<pre>
g++ -Winvalid-pch -x c++-header -g -O2 -o ./stdc++.h.gch /mnt/share/bld/H-x86-gcc.20071201/include/c++/4.3.0/x86_64-unknown-linux-gnu/bits/stdc++.h
</pre>

<p>The resulting file will be quite large: the current size is around
thirty megabytes. </p>

<p>How to use the resulting file.</p>

<pre>
g++ -I. -include stdc++.h  -H -g -O2 hello.cc 
</pre>

<p>Verification that the PCH file is being used is easy:</p>

<pre>
g++ -Winvalid-pch -I. -include stdc++.h -H -g -O2 hello.cc -o test.exe
! ./stdc++.h.gch
. /mnt/share/bld/H-x86-gcc.20071201/include/c++/4.3.0/iostream
. /mnt/share/bld/H-x86-gcc.20071201include/c++/4.3.0/string
</pre>

<p>The exclamation point to the left of the <code>stdc++.h.gch</code> listing means that the generated PCH file was used, and thus the </p>
<p></p>

<p> Detailed information about creating precompiled header files can be found in the GCC <a href="http://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html">documentation</a>.
</p>


<hr />
<h2><a name="3.0">Namespaces</a></h2>


<p> There are three main namespaces.
</p>

<ul>
<li>std
<p>The ISO C++ standards specify that "all library entities are defined
within namespace std." This includes namepaces nested
within <code>namespace std</code>, such as <code>namespace
std::tr1</code>.
</p>
</li>
<li>abi
<p>Specified by the C++ ABI. This ABI specifies a number of type and
function APIs supplemental to those required by the ISO C++ Standard,
but necessary for interoperability.
</p>
</li>

<li>__gnu_
<p>Indicating one of several GNU extensions. Choices
include <code>__gnu_cxx</code>, <code>__gnu_debug</code>, <code>__gnu_parallel</code>,
and <code>__gnu_pbds</code>.
</p></li>
</ul>

<p> A complete list of implementation namespaces (including namespace contents) is available in the generated source <a href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespaces.html">documentation</a>. 
</p>


<hr />
<h2><a name="3.1">Namespace <code>std::</code></a></h2>

<p>
      One standard requirement is that the library components are defined
      in <code>namespace std::</code>. Thus, in order to use these types or
      functions, one must do one of two things:
</p>

      <div class="itemizedlist"><ul type="disc"> <li><p>put a kind of
<span class="emphasis"><i>using-declaration</i></span> in your source
(either <code>using namespace std;</code> or i.e. <code>using
std::string;</code>) This approach works well for individual source files, but
should not be used in a global context, like header files.
	  </p></li> <li><p>use a <span class="emphasis"><i>fully
qualified name</i></span> for each library symbol
(i.e. <code>std::string</code>, <code>std::cout</code>) Always can be
used, and usually enhanced, by strategic use of typedefs. (In the
cases where the qualified verbiage becomes unwieldy.)
	  </p></li>
</ul></div>

<hr />
<h2><a name="3.2">Using namespace composition</a></h2>

<p>
Best practice in programming suggests sequestering new data or
functionality in a sanely-named, unique namespace whenever
possible. This is considered an advantage over dumping everything in
the global namespace, as then name look-up can be explicitly enabled or
disabled as above, symbols are consistently mangled without repetitive
naming prefixes or macros, etc.
</p>

<p>For instance, consider a project that defines most of its classes in <code>namespace gtk</code>. It is possible to
	adapt <code>namespace gtk</code> to <code>namespace std</code> by using a C++-feature called
	<span class="emphasis"><i>namespace composition</i></span>. This is what happens if
	a <span class="emphasis"><i>using</i></span>-declaration is put into a
	namespace-definition: the imported symbol(s) gets imported into the
	currently active namespace(s). For example:
</p>
<pre class="programlisting">
namespace gtk 
{
  using std::string;
  using std::tr1::array;

  class Window { ... };
}
</pre>
<p>
	In this example, <code>std::string</code> gets imported into
	<code>namespace gtk</code>.  The result is that use of
	<code>std::string</code> inside namespace gtk can just use <code>string</code>, without the explicit qualification. 
	As an added bonus, 
	<code>std::string</code> does not get imported into
	the global namespace.  Additionally, a more elaborate arrangement can be made for backwards compatibility and portability, whereby the
	<code>using</code>-declarations can wrapped in macros that
	are set based on autoconf-tests to either &quot;&quot; or i.e. <code>using
	  std::string;</code> (depending on whether the system has
	libstdc++ in <code>std::</code> or not).  (ideas from
	<tt>&lt;<a href="mailto:llewelly@dbritsch.dsl.xmission.com">llewelly@dbritsch.dsl.xmission.com</a>&gt;</tt>, Karl Nelson
	<tt>&lt;<a href="mailto:kenelson@ece.ucdavis.edu">kenelson@ece.ucdavis.edu</a>&gt;</tt>)
</p>

<hr />
<h2><a name="6">Macros for libstdc++</a></h2>

   <p>All pre-processor switches and configurations are all gathered
      in the file <code>c++config.h</code>, which is generated during
      the libstdc++ configuration and build process, and included by
      files part of the public libstdc++ API. Most of these macros
      should not be used by consumers of libstdc++, and are reserved
      for internal implementation use. <strong>These macros cannot be
      redefined</strong>. However, a select handful of these macro
      control libstdc++ extensions and extra features, or provide
      versioning information for the API, and are able to be used.
   </p>

   <p>All library macros begin with <code>_GLIBCXX_</code> (except for
   versions 3.1.x to 3.3.x, which use <code>_GLIBCPP_</code>).
   </p>

   <p>Below is the macro which users may check for library version
      information. </p>

    <dl>
    <dt><code>__GLIBCXX__</code></dt> <dd>The current version of
    libstdc++ in compressed ISO date format, form of an unsigned
    long. For details on the value of this particular macro for a
    particular release, please consult this <a href="abi.html">
    document</a>.</dd> </dl>

   <p>Below are the macros which users may change with #define/#undef or
      with -D/-U compiler flags.  The default state of the symbol is
      listed.</p>

   <p>&quot;Configurable&quot; (or &quot;Not configurable&quot;) means
      that the symbol is initially chosen (or not) based on
      --enable/--disable options at library build and configure time
      (documented <a href="../configopts.html">here</a>), with the
      various --enable/--disable choices being translated to
      #define/#undef).
   </p> 

   <p> &quot;ABI&quot; means that changing from the default value may
  mean changing the ABI of compiled code. In other words, these
  choices control code which has already been compiled (i.e., in a
  binary such as libstdc++.a/.so).  If you explicitly #define or
  #undef these macros, the <em>headers</em> may see different code
  paths, but the <em>libraries</em> which you link against will not.
  Experimenting with different values with the expectation of
  consistent linkage requires changing the config headers before
  building/installing the library.
   </p>   

    <dl>
    <dt><code>_GLIBCXX_DEPRECATED</code></dt>
    <dd>Defined by default. Not configurable. ABI-changing. Turning this off
        removes older ARM-style iostreams code, and other anachronisms
        from the API.  This macro is dependent on the version of the
        standard being tracked, and as a result may give different results for
        <code>-std=c++98</code> and <code>-std=c++0x</code>. This may
        be useful in updating old C++ code which no longer meet the
        requirements of the language, or for checking current code
        against new language standards.  </dd>

    <dt><code>_GLIBCXX_FORCE_NEW</code></dt> <dd>Undefined by
    default. When defined, memory allocation and allocators controlled
    by libstdc++ call operator new/delete without caching and
    pooling. Configurable via
    <code>--enable-libstdcxx-allocator</code>. ABI-changing.
    </dd>


    <dt><code>_GLIBCXX_CONCEPT_CHECKS</code></dt> <dd>Undefined by
    default.  Configurable via <code>--enable-concept-checks</code>.
    When defined, performs compile-time checking on certain template
    instantiations to detect violations of the requirements of the
    standard.  This is described in more detail <a
    href="../19_diagnostics/howto.html#3">here</a>.</dd>

    <dt><code>_GLIBCXX_DEBUG</code></dt>
    <dd>Undefined by default. When defined, compiles
    user code using the <a href="../ext/debug.html#safe">libstdc++ debug
    mode</a>.
    </dd>
    <dt><code>_GLIBCXX_DEBUG_PEDANTIC</code></dt>
    <dd>Undefined by default. When defined while
    compiling with the <a href="../ext/debug.html#safe">libstdc++ debug
    mode</a>, makes the debug mode extremely picky by making the use
    of libstdc++ extensions and libstdc++-specific behavior into
    errors.
    </dd>
    <dt><code>_GLIBCXX_PARALLEL</code></dt>
    <dd>Undefined by default. When defined, compiles
    user code using the <a href="../ext/parallel_mode.html">libstdc++ parallel
    mode</a>.
    </dd>
    </dl>

<hr />
<h2><a name="7">The Standard C++ library and multithreading</a></h2>
   <p>This section discusses issues surrounding the proper compilation
      of multithreaded applications which use the Standard C++
      library.  This information is GCC-specific since the C++
      standard does not address matters of multithreaded applications.
      Unless explicitly prefaced, all information in this section is
      relevant to the GCC 3.0 release and all later releases.
   </p>
   <p>Earlier GCC releases had a somewhat different approach to
      threading configuration and proper compilation.  Before GCC 3.0,
      configuration of the threading model was dictated by compiler
      command-line options and macros (both of which were somewhat
      thread-implementation and port-specific).  There were no
      guarantees related to being able to link code compiled with one
      set of options and macro setting with another set.  For GCC 3.0,
      configuration of the threading model used with libraries and
      user-code is performed when GCC is configured and built using
      the --enable-threads and --disable-threads options.  The ABI is
      stable for symbol name-mangling and limited functional
      compatibility exists between code compiled under different
      threading models.
   </p>
   <p>All normal disclaimers aside, multithreaded C++ application are
      only supported when libstdc++ and all user code was built with
      compilers which report (via <code> gcc/g++ -v </code>) the same thread
      model and that model is not <em>single</em>.  As long as your
      final application is actually single-threaded, then it should be
      safe to mix user code built with a thread model of
      <em>single</em> with a libstdc++ and other C++ libraries built
      with another thread model useful on the platform.  Other mixes
      may or may not work but are not considered supported.  (Thus, if
      you distribute a shared C++ library in binary form only, it may
      be best to compile it with a GCC configured with
      --enable-threads for maximal interchangeability and usefulness
      with a user population that may have built GCC with either
      --enable-threads or --disable-threads.)
   </p>
   <p>When you link a multithreaded application, you will probably
      need to add a library or flag to g++.  This is a very
      non-standardized area of GCC across ports.  Some ports support a
      special flag (the spelling isn't even standardized yet) to add
      all required macros to a compilation (if any such flags are
      required then you must provide the flag for all compilations not
      just linking) and link-library additions and/or replacements at
      link time.  The documentation is weak.  Here is a quick summary
      to display how ad hoc this is: On Solaris, both -pthreads and
      -threads (with subtly different meanings) are honored.  On OSF,
      -pthread and -threads (with subtly different meanings) are
      honored.  On Linux/i386, -pthread is honored.  On FreeBSD,
      -pthread is honored.  Some other ports use other switches.
      AFAIK, none of this is properly documented anywhere other than
      in ``gcc -dumpspecs'' (look at lib and cpp entries).
   </p>
   <p>See <a href="../faq/index.html#5_6">FAQ</a> (general overview), <a
      href="../23_containers/howto.html#3">23</a> (containers), and <a
      href="../27_io/howto.html#9">27</a> (I/O) for more information.
   </p>
   <p>The libstdc++ library has been designed so that it can be used in
      multithreaded applications (with libstdc++-v2 this was
      only true of the STL parts.)  The first problem is
      finding a <em>fast</em> method of implementation portable to all
      platforms.  Due to historical reasons, some of the library is
      written against per-CPU-architecture spinlocks and other parts
      against the gthr.h abstraction layer which is provided by gcc.
      A minor problem that pops up every so often is different
      interpretations of what &quot;thread-safe&quot; means for a
      library (not a general program).  We currently use the <a
      href="http://www.sgi.com/tech/stl/thread_safety.html">same
      definition that SGI</a> uses for their STL subset.  However, the
      exception for read-only containers only applies to the STL
      components. This definition is widely-used and something similar
      will be used in the next version of the C++ standard library.
   </p>
   <p>Here is a small link farm to threads (no pun) in the mail archives
      that discuss the threading problem.  Each link is to the first
      relevant message in the thread; from there you can use
      &quot;Thread Next&quot; to move down the thread.  This farm is in
      latest-to-oldest order.
   </p>
      <ul>
        <li>Our threading expert Loren gives a breakdown of
        <a href="http://gcc.gnu.org/ml/libstdc++/2001-10/msg00024.html">the
        six situations involving threads</a> for the 3.0 release series.</li>
        <li><a href="http://gcc.gnu.org/ml/libstdc++/2001-05/msg00384.html">
        This message</a> inspired a recent updating of issues with threading
        and the SGI STL library.  It also contains some example
        POSIX-multithreaded STL code.</li>
      </ul>
   <p> (A large selection of links to older messages has been removed; many
      of the messages from 1999 were lost in a disk crash, and the few
      people with access to the backup tapes have been too swamped with work
      to restore them.  Many of the points have been superseded anyhow.)
   </p>
   <p>This section will be updated as new and interesting issues come
      to light.
   </p>
   <p>Return <a href="#top">to top of page</a> or
      <a href="../faq/index.html">to the FAQ</a>.
   </p>

<hr />
<h2><a name="5">Behavior specific to libstdc++</a></h2>
   <p>The ISO standard defines the following phrase:
   </p>
     <blockquote><dl>
     <dt><code>[1.3.5] implementation-defined behavior</code></dt>
     <dd>behavior, for a well-formed program construct and correct data, that
         depends on the implementation <strong>and that each implementation
         shall document</strong>.
     </dd>
     </dl></blockquote>
   <p>We do so here, for the C++ library only.  Behavior of the compiler,
      linker, runtime loader, and other elements of &quot;the
      implementation&quot; are documented elsewhere.  Everything listed in
      Annex B, Implementation Qualities, are also part of the compiler, not
      the library.
   </p>
   <p>For each entry, we give the section number of the standard, when
      applicable.  This list is probably incomplet and inkorrekt.
   </p>
   <p><strong>[1.9]/11 #3</strong> If <code>isatty(3)</code> is true, then
      interactive stream support is implied.
   </p>
   <p><strong>[17.4.4.5]</strong> Non-reentrant functions are probably best
      discussed in the various sections on multithreading (see above).
   </p>
   <!-- [17.4.4.8]/3 says any function that doesn't have an exception-spec
        can throw whatever we want; see also its footnote.  Let's list those
        in the sections where the function itself occurs.
   -->
   <p><strong>[18.1]/4</strong> The type of <code>NULL</code> is described
      <a href="../18_support/howto.html#1">here</a>.
   </p>
   <p><strong>[18.3]/8</strong> Even though it's listed in the library
      sections, libstdc++ has zero control over what the cleanup code hands
      back to the runtime loader.  Talk to the compiler people.  :-)
   </p>
   <p><strong>[18.4.2.1]/5</strong> (bad_alloc),<br />
      <strong>[18.5.2]/5</strong> (bad_cast),<br />
      <strong>[18.5.3]/5</strong> (bad_typeid),<br />
      <strong>[18.6.1]/8</strong> (exception),<br />
      <strong>[18.6.2.1]/5</strong> (bad_exception):  The <code>what()</code>
      member function of class <code>std::exception</code>, and these other
      classes publicly derived from it, simply returns the name of the
      class.  But they are the <em>mangled</em> names; you will need to call
      <code>c++filt</code> and pass the names as command-line parameters to
      demangle them, or call a
      <a href="../18_support/howto.html#5">runtime demangler function</a>.
      (The classes in <code>&lt;stdexcept&gt;</code> have constructors which
      require an argument to use later for <code>what()</code> calls, so the
      problem of <code>what()</code>'s value does not arise in most
      user-defined exceptions.)
   </p>
   <p><strong>[18.5.1]/7</strong> The return value of
      <code>std::type_info::name()</code> is the mangled type name (see the
      previous entry for more).
   </p>
   <p><strong>[20.1.5]/5</strong> <em>&quot;Implementors are encouraged to
      supply libraries that can accept allocators that encapsulate more
      general memory models and that support non-equal instances.  In such
      implementations, any requirements imposed on allocators by containers
      beyond those requirements that appear in Table 32, and the semantics
      of containers and algorithms when allocator instances compare
      non-equal, are implementation-defined.&quot;</em>  As yet we don't
      have any allocators which compare non-equal, so we can't describe how
      they behave.
   </p>
   <p><strong>[21.1.3.1]/3,4</strong>,<br />
      <strong>[21.1.3.2]/2</strong>,<br />
      <strong>[23.*]'s foo::iterator</strong>,<br />
      <strong>[27.*]'s foo::*_type</strong>,<br />
      <strong>others...</strong>
      Nope, these types are called implementation-defined because you
      shouldn't be taking advantage of their underlying types.  Listing them
      here would defeat the purpose.  :-)
   </p>
   <p><strong>[21.1.3.1]/5</strong> I don't really know about the mbstate_t
      stuff... see the <a href="../22_locale/howto.html">chapter 22 notes</a>
      for what does exist.
   </p>
   <p><strong>[22.*]</strong> Anything and everything we have on locale
      implementation will be described
      <a href="../22_locale/howto.html">over here</a>.
   </p>
   <p><strong>[26.2.8]/9</strong> I have no idea what
      <code>complex&lt;T&gt;</code>'s pow(0,0) returns.
   </p>
   <p><strong>[27.4.2.4]/2</strong> Calling
      <code>std::ios_base::sync_with_stdio</code> after I/O has already been
      performed on the standard stream objects will
      flush the buffers, and <!-- this line might go away -->
      destroy and recreate the underlying buffer instances.  Whether or not
      the previously-written I/O is destroyed in this process depends mostly
      on the --enable-libio choice:  for stdio, if the written data is
      already in the stdio buffer, the data may be completely safe!
   </p>
   <p><strong>[27.6.1.1.2]</strong>,<br />
      <strong>[27.6.2.3]</strong> The I/O sentry ctor and dtor can perform
      additional work than the minimum required.  We are not currently taking
      advantage of this yet.
   </p>
   <p><strong>[27.7.1.3]/16</strong>,<br />
      <strong>[27.8.1.4]/10</strong>
      The effects of <code>pubsetbuf/setbuf</code> are described
      <a href="../27_io/howto.html#2">in this chapter</a>.
   </p>
   <p><strong>[27.8.1.4]/16</strong> Calling <code>fstream::sync</code> when
      a get area exists will... whatever <code>fflush()</code> does, I think.
   </p>
   <p>Return <a href="#top">to top of page</a> or
      <a href="../faq/index.html">to the FAQ</a>.
   </p>

    <!--
    <dt><code></code></dt>
    <dd>
    </dd>
    -->
   <p>Return <a href="#top">to top of page</a> or
      <a href="../faq/index.html">to the FAQ</a>.
   </p>



<!-- ####################################################### -->

<hr />
<p class="fineprint"><em>
See <a href="license.html">license.html</a> for copying conditions.
Comments and suggestions are welcome, and may be sent to
<a href="mailto:libstdc++@gcc.gnu.org">the libstdc++ mailing list</a>.
</em></p>


</body>
</html>


