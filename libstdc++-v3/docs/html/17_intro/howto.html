<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html
          PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
   <meta name="AUTHOR" content="pme@gcc.gnu.org (Phil Edwards), Benjamin Kosnik, Felix Natter" />
   <meta name="KEYWORDS" content="HOWTO, libstdc++, gcc, g++, libg++, STL" />
   <meta name="DESCRIPTION" content="HOWTO for libstdc++ chapter 17." />
   <meta name="GENERATOR" content="vi and eight fingers" />
   <title>libstdc++ HOWTO:  Chapter 17: Library Introduction</title>
<link rel="StyleSheet" href="../lib3styles.css" type="text/css" />
<link rel="Start" href="../documentation.html" type="text/html"
 title="GNU C++ Standard Library" />
<link rel="Next" href="../18_support/howto.html" type="text/html"
  title="Library Support" />
<link rel="Copyright" href="license.html" type="text/html" />
<link rel="Help" href="../faq/index.html" type="text/html" title="F.A.Q." />
</head>
<body>

<h1 class="centered"><a name="top">Chapter 17:  Library Introduction</a></h1>

<p>Chapter 17 is actually a list of definitions and descriptions used
   in the following chapters of the Standard when describing the actual
   library.  Here, we use &quot;Introduction&quot; as an introduction
   to the <em>GNU implementation of</em> the ISO Standard C++ Library.
</p>


<!-- ####################################################### -->
<hr />
<h1>Contents</h1>
<ul>
   <li><a href="#2.1">Header Files</a></li>
   <li><a href="#5">Implementation specific behavior</a></li>
   <li><a href="#6">Macros</a></li>
   <li><a href="#3">Multithreading</a></li>
</ul>

<hr />

<!-- ####################################################### -->

<h2><a name="2.1">Header Files</a></h2>
   <p>The C++ standard specifies 50 header files that must be
      available to all hosted implementations.  Actually, the word
      &quot;files&quot; is a misnomer, since the contents of the headers
      don't necessarily have to be in any kind of external file.  The
      only rule is that when one <code>#include</code>'s a certain header, the
      contents of that header, as defined by the Standard, become
      available, no matter how.
   </p>

<p>C++98/03 include files:
</p>
<pre>
C++ Library Headers
algorithm	ios      	new     	stack
bitset		iosfwd   	numeric 	stdexcept
complex     	iostream 	ostream 	streambuf
    		istream  	queue      	string
deque      	iterator 			
exception  	limits   			typeinfo
fstream    	list     	set
functional 	locale   	map
iomanip    	memory   	sstream 	

C++ Headers for C Library Facilities
cassert   	cfloat        	cmath         	cstddef     
ccomplex  		     	csetjmp       	cstdio      	ctime
cctype    	ciso646       	csignal			    	
cerrno    	climits       	cstdarg       	cstdlib     	cwchar
	    	clocale       		      	cstring     	cwctype
</pre>

<p>C++0x include files:
</p>
<pre>
C++ Library Headers
algorithm	ios      	new     	stack
array      	iosfwd   	numeric 	stdexcept
bitset     	iostream 	ostream 	streambuf
complex    	istream  	queue      	string
deque      	iterator 	random		system_error
exception  	limits   	regex      	tuple
fstream    	list     	set        	type_traits
functional 	locale   	map        	typeinfo
iomanip    	memory   	sstream 	

C++ Headers for C Library Facilities
cassert   	cfloat        	cmath         	cstddef     	ctgmath
ccomplex  	cinttypes     	csetjmp       	cstdio      	ctime
cctype    	ciso646       	csignal       	cstdint     	cuchar
cerrno    	climits       	cstdarg       	cstdlib     	cwchar
cfenv     	clocale       	cstdbool      	cstring     	cwctype
</pre>

<p>In addition, TR1 includes as:
</p>
<pre>
C++ Library Headers
tr1/array, tr1/complex, tr1/functional, tr1/memory, tr1/random,
tr1/regex, tr1/tuple, tr1/type_traits, tr1/unordered_map,
tr1/unordered_set, tr1/utility

C++ Headers for C Library Facilities
tr1/cmath, tr1/ccomplex, tr1/cfenv, tr1/cfloat, tr1/cinttypes,
tr1/climits, tr1/cstdarg, tr1/cstdbool, tr1/cstdint, tr1/cstdio,
tr1/cstdlib, tr1/ctgmath, tr1/ctime, tr1/cwchar, tr1/cwctype

C++ Compatibility Headers for C Library Facilities
tr1/complex.h, tr1/ctype.h, tr1/float.h, tr1/limits.h, tr1/math.h,
tr1/stdarg.h, tr1/stdbool.h, tr1/stdint.h, tr1/stdio.h, tr1/stdlib.h,
tr1/tgmath.h, tr1/wchar.h, tr1/wctype.h
</pre>

<hr />
<h2><a name="2.2">Headers and <code>namespace std::</code></a></h2>
<p>
	You should not use the C-headers (except for system-level
	headers) from C++ programs. Instead, you should use a set of
	headers that are named by prepending 'c' and, as usual,
	omitting the extension (.h). For example, instead of using
	<tt>&lt;math.h&gt;</tt>, you
	should use <tt>&lt;cmath&gt;</tt>. In some cases this has
	the advantage that the C++-header is more standardized than
	the C-header (i.e. <tt>&lt;ctime&gt;</tt> (almost)
	corresponds to either <tt>&lt;time.h&gt;</tt> or <tt>&lt;sys/time.h&gt;</tt>).

	The standard specifies that if you include the C-style header
	(<tt>&lt;math.h&gt;</tt> in
	this case), the symbols will be available both in the global
	namespace and in namespace <code>std::</code> (but
	libstdc++ does not yet have fully compliant headers) On the
	other hand, if you include only the new header (i.e. <tt>&lt;cmath&gt;</tt>), the symbols
	will only be defined in namespace <code>std::</code>
	(and macros will be converted to inline-functions).
      </p>

<p>FIXME: this is no longer accurate.</p>

<p>
	For more information on this, and for information on how the
	GNU C++ implementation might reuse (&quot;shadow&quot;) the C
	library-functions, have a look at <a href="http://www.cantrip.org/cheaders.html" target="_top">
	  www.cantrip.org</a>.
      </p>

<hr />
<h2><a name="2.5">Namespace <code>std::</code></a></h2>

<p>
      One standard requirement is that the library components are defined
      in <code>namespace std::</code>. Thus, in order to use these types or
      functions, one must do one of two things:
</p>

      <div class="itemizedlist"><ul type="disc"> <li><p>put a kind of
<span class="emphasis"><i>using-declaration</i></span> in your source
(either <code>using namespace std;</code> or i.e. <code>using
std::string;</code>) This approach works well for individual source files, but
should not be used in a global context, like header files.
	  </p></li> <li><p>use a <span class="emphasis"><i>fully
qualified name</i></span> for each library symbol
(i.e. <code>std::string</code>, <code>std::cout</code>) Always can be
used, and usually enhanced, by strategic use of typedefs. (In the
cases where the qualified verbage becomes unweidly.)
	  </p></li>
</ul>

<hr />
<h2><a name="2.6">Using namespace composition</code></a></h2>

<p>
	<a href="http://gtkmm.sourceforge.net" target="_top">Gtk--</a> defines
	most of its classes in namespace Gtk::. Thus, it was possible to
	adapt Gtk-- to namespace std:: by using a C++-feature called
	<span class="emphasis"><i>namespace composition</i></span>. This is what happens if
	you put a <span class="emphasis"><i>using</i></span>-declaration into a
	namespace-definition: the imported symbol(s) gets imported into the
	currently active namespace(s). For example:
	<pre class="programlisting">
	  namespace Gtk {
	  using std::string;
	  class Window { ... }
	  }
	</pre>
	In this example, <code>std::string</code> gets imported into
	namespace Gtk::.  The result is that you don't have to use
	<code>std::string</code> in this header, but still
	<code>std::string</code> does not get imported into
	the global namespace (::) unless the user does
	<code>using namespace Gtk;</code> (which is not recommended
	practice for Gtk--, so it is not a problem).  Additionally, the
	<code>using</code>-declarations are wrapped in macros that
	are set based on autoconf-tests to either &quot;&quot; or i.e. <code>using
	  std::string;</code> (depending on whether the system has
	libstdc++ in <code>std::</code> or not).  (ideas from
	<tt>&lt;<a href="mailto:llewelly@dbritsch.dsl.xmission.com">llewelly@dbritsch.dsl.xmission.com</a>&gt;</tt>, Karl Nelson
	<tt>&lt;<a href="mailto:kenelson@ece.ucdavis.edu">kenelson@ece.ucdavis.edu</a>&gt;</tt>)
</p>

<hr />
<h2><a name="3">The Standard C++ library and multithreading</a></h2>
   <p>This section discusses issues surrounding the proper compilation
      of multithreaded applications which use the Standard C++
      library.  This information is GCC-specific since the C++
      standard does not address matters of multithreaded applications.
      Unless explicitly prefaced, all information in this section is
      current as of the GCC 3.0 release and all later point releases.
   </p>
   <p>Earlier GCC releases had a somewhat different approach to
      threading configuration and proper compilation.  Before GCC 3.0,
      configuration of the threading model was dictated by compiler
      command-line options and macros (both of which were somewhat
      thread-implementation and port-specific).  There were no
      guarantees related to being able to link code compiled with one
      set of options and macro setting with another set.  For GCC 3.0,
      configuration of the threading model used with libraries and
      user-code is performed when GCC is configured and built using
      the --enable-threads and --disable-threads options.  The ABI is
      stable for symbol name-mangling and limited functional
      compatibility exists between code compiled under different
      threading models.
   </p>
   <p>All normal disclaimers aside, multithreaded C++ application are
      only supported when libstdc++ and all user code was built with
      compilers which report (via <code> gcc/g++ -v </code>) the same thread
      model and that model is not <em>single</em>.  As long as your
      final application is actually single-threaded, then it should be
      safe to mix user code built with a thread model of
      <em>single</em> with a libstdc++ and other C++ libraries built
      with another thread model useful on the platform.  Other mixes
      may or may not work but are not considered supported.  (Thus, if
      you distribute a shared C++ library in binary form only, it may
      be best to compile it with a GCC configured with
      --enable-threads for maximal interchangeability and usefulness
      with a user population that may have built GCC with either
      --enable-threads or --disable-threads.)
   </p>
   <p>When you link a multithreaded application, you will probably
      need to add a library or flag to g++.  This is a very
      non-standardized area of GCC across ports.  Some ports support a
      special flag (the spelling isn't even standardized yet) to add
      all required macros to a compilation (if any such flags are
      required then you must provide the flag for all compilations not
      just linking) and link-library additions and/or replacements at
      link time.  The documentation is weak.  Here is a quick summary
      to display how ad hoc this is: On Solaris, both -pthreads and
      -threads (with subtly different meanings) are honored.  On OSF,
      -pthread and -threads (with subtly different meanings) are
      honored.  On Linux/i386, -pthread is honored.  On FreeBSD,
      -pthread is honored.  Some other ports use other switches.
      AFAIK, none of this is properly documented anywhere other than
      in ``gcc -dumpspecs'' (look at lib and cpp entries).
   </p>
   <p>See <a href="../faq/index.html#3">FAQ</a> (general overview), <a
      href="../23_containers/howto.html#3">23</a> (containers), and <a
      href="../27_io/howto.html#9">27</a> (I/O) for more information.
   </p>
   <p>The libstdc++ library (unlike libstdc++-v2, all of it, not
      just the STL) has been designed so that multithreaded
      applications using it may be written.  The first problem is
      finding a <em>fast</em> method of implementation portable to all
      platforms.  Due to historical reasons, some of the library is
      written against per-CPU-architecture spinlocks and other parts
      against the gthr.h abstraction layer which is provided by gcc.
      A minor problem that pops up every so often is different
      interpretations of what &quot;thread-safe&quot; means for a
      library (not a general program).  We currently use the <a
      href="http://www.sgi.com/tech/stl/thread_safety.html">same
      definition that SGI</a> uses for their STL subset.  However, the
      exception for read-only containers only applies to the STL
      components.
   </p>
   <p>Here is a small link farm to threads (no pun) in the mail archives
      that discuss the threading problem.  Each link is to the first
      relevant message in the thread; from there you can use
      &quot;Thread Next&quot; to move down the thread.  This farm is in
      latest-to-oldest order.
   </p>
      <ul>
        <li>Our threading expert Loren gives a breakdown of
        <a href="http://gcc.gnu.org/ml/libstdc++/2001-10/msg00024.html">the
        six situations involving threads</a> for the 3.0 release series.</li>
        <li><a href="http://gcc.gnu.org/ml/libstdc++/2001-05/msg00384.html">
        This message</a> inspired a recent updating of issues with threading
        and the SGI STL library.  It also contains some example
        POSIX-multithreaded STL code.</li>
      </ul>
   <p> (A large selection of links to older messages has been removed; many
      of the messages from 1999 were lost in a disk crash, and the few
      people with access to the backup tapes have been too swamped with work
      to restore them.  Many of the points have been superseded anyhow.)
   </p>
   <p>This section will be updated as new and interesting issues come
      to light.
   </p>
   <p>Return <a href="#top">to top of page</a> or
      <a href="../faq/index.html">to the FAQ</a>.
   </p>

<hr />
<h2><a name="5">Behavior specific to libstdc++</a></h2>
   <p>The ISO standard defines the following phrase:
   </p>
     <blockquote><dl>
     <dt><code>[1.3.5] implementation-defined behavior</code></dt>
     <dd>behavior, for a well-formed program construct and correct data, that
         depends on the implementation <strong>and that each implementation
         shall document</strong>.
     </dd>
     </dl></blockquote>
   <p>We do so here, for the C++ library only.  Behavior of the compiler,
      linker, runtime loader, and other elements of &quot;the
      implementation&quot; are documented elsewhere.  Everything listed in
      Annex B, Implementation Qualities, are also part of the compiler, not
      the library.
   </p>
   <p>For each entry, we give the section number of the standard, when
      applicable.  This list is probably incomplet and inkorrekt.
   </p>
   <p><strong>[1.9]/11 #3</strong> If <code>isatty(3)</code> is true, then
      interactive stream support is implied.
   </p>
   <p><strong>[17.4.4.5]</strong> Non-reentrant functions are probably best
      discussed in the various sections on multithreading (see above).
   </p>
   <!-- [17.4.4.8]/3 says any function that doesn't have an exception-spec
        can throw whatever we want; see also its footnote.  Let's list those
        in the sections where the function itself occurs.
   -->
   <p><strong>[18.1]/4</strong> The type of <code>NULL</code> is described
      <a href="../18_support/howto.html#1">here</a>.
   </p>
   <p><strong>[18.3]/8</strong> Even though it's listed in the library
      sections, libstdc++ has zero control over what the cleanup code hands
      back to the runtime loader.  Talk to the compiler people.  :-)
   </p>
   <p><strong>[18.4.2.1]/5</strong> (bad_alloc),<br />
      <strong>[18.5.2]/5</strong> (bad_cast),<br />
      <strong>[18.5.3]/5</strong> (bad_typeid),<br />
      <strong>[18.6.1]/8</strong> (exception),<br />
      <strong>[18.6.2.1]/5</strong> (bad_exception):  The <code>what()</code>
      member function of class <code>std::exception</code>, and these other
      classes publicly derived from it, simply returns the name of the
      class.  But they are the <em>mangled</em> names; you will need to call
      <code>c++filt</code> and pass the names as command-line parameters to
      demangle them, or call a
      <a href="../18_support/howto.html#5">runtime demangler function</a>.
      (The classes in <code>&lt;stdexcept&gt;</code> have constructors which
      require an argument to use later for <code>what()</code> calls, so the
      problem of <code>what()</code>'s value does not arise in most
      user-defined exceptions.)
   </p>
   <p><strong>[18.5.1]/7</strong> The return value of
      <code>std::type_info::name()</code> is the mangled type name (see the
      previous entry for more).
   </p>
   <p><strong>[20.1.5]/5</strong> <em>&quot;Implementors are encouraged to
      supply libraries that can accept allocators that encapsulate more
      general memory models and that support non-equal instances.  In such
      implementations, any requirements imposed on allocators by containers
      beyond those requirements that appear in Table 32, and the semantics
      of containers and algorithms when allocator instances compare
      non-equal, are implementation-defined.&quot;</em>  As yet we don't
      have any allocators which compare non-equal, so we can't describe how
      they behave.
   </p>
   <p><strong>[21.1.3.1]/3,4</strong>,<br />
      <strong>[21.1.3.2]/2</strong>,<br />
      <strong>[23.*]'s foo::iterator</strong>,<br />
      <strong>[27.*]'s foo::*_type</strong>,<br />
      <strong>others...</strong>
      Nope, these types are called implementation-defined because you
      shouldn't be taking advantage of their underlying types.  Listing them
      here would defeat the purpose.  :-)
   </p>
   <p><strong>[21.1.3.1]/5</strong> I don't really know about the mbstate_t
      stuff... see the <a href="../22_locale/howto.html">chapter 22 notes</a>
      for what does exist.
   </p>
   <p><strong>[22.*]</strong> Anything and everything we have on locale
      implementation will be described
      <a href="../22_locale/howto.html">over here</a>.
   </p>
   <p><strong>[26.2.8]/9</strong> I have no idea what
      <code>complex&lt;T&gt;</code>'s pow(0,0) returns.
   </p>
   <p><strong>[27.4.2.4]/2</strong> Calling
      <code>std::ios_base::sync_with_stdio</code> after I/O has already been
      performed on the standard stream objects will
      flush the buffers, and <!-- this line might go away -->
      destroy and recreate the underlying buffer instances.  Whether or not
      the previously-written I/O is destroyed in this process depends mostly
      on the --enable-libio choice:  for stdio, if the written data is
      already in the stdio buffer, the data may be completely safe!
   </p>
   <p><strong>[27.6.1.1.2]</strong>,<br />
      <strong>[27.6.2.3]</strong> The I/O sentry ctor and dtor can perform
      additional work than the minimum required.  We are not currently taking
      advantage of this yet.
   </p>
   <p><strong>[27.7.1.3]/16</strong>,<br />
      <strong>[27.8.1.4]/10</strong>
      The effects of <code>pubsetbuf/setbuf</code> are described
      <a href="../27_io/howto.html#2">in this chapter</a>.
   </p>
   <p><strong>[27.8.1.4]/16</strong> Calling <code>fstream::sync</code> when
      a get area exists will... whatever <code>fflush()</code> does, I think.
   </p>
   <p>Return <a href="#top">to top of page</a> or
      <a href="../faq/index.html">to the FAQ</a>.
   </p>

<hr />
<h2><a name="6">Macros for libstdc++</a></h2>

   <p>All pre-processor switches and configurations are all gathered
      in the file <code>c++config.h</code>, which is generated during
      the libstdc++ configuration and build process, and included by
      files part of the public libstdc++ API. Most of these macros
      should not be used by consumers of libstdc++, and are reserved
      for internal implementation use. <strong>These macros cannot be
      redefined</strong>. However, a select handful of these macro
      control libstdc++ extensions and extra features, or provide
      versioning information for the API, and are able to be used.
   </p>

   <p>All library macros begin with <code>_GLIBCXX_</code> (except for
   versions 3.1.x to 3.3.x, which use <code>_GLIBCPP_</code>).
   </p>

   <p>Below is the macro which users may check for library version
      information. </p>

    <dl>
    <dt><code>__GLIBCXX__</code></dt> <dd>The current version of
    libstdc++ in compressed ISO date format, form of an unsigned
    long. For details on the value of this particular macro for a
    particular release, please consult this <a href="abi.html">
    document</a>.</dd> </dl>

   <p>Below are the macros which users may change with #define/#undef or
      with -D/-U compiler flags.  The default state of the symbol is
      listed.</p>

   <p>&quot;Configurable&quot; (or &quot;Not configurable&quot;) means
      that the symbol is initially chosen (or not) based on
      --enable/--disable options at library build and configure time
      (documented <a href="../configopts.html">here</a>), with the
      various --enable/--disable choices being translated to
      #define/#undef).
   </p> 

   <p> &quot;ABI&quot; means that changing from the default value may
  mean changing the ABI of compiled code. In other words, these
  choices control code which has already been compiled (i.e., in a
  binary such as libstdc++.a/.so).  If you explicitly #define or
  #undef these macros, the <em>headers</em> may see different code
  paths, but the <em>libraries</em> which you link against will not.
  Experimenting with different values with the expectation of
  consistent linkage requires changing the config headers before
  building/installing the library.
   </p>   

    <dl>
    <dt><code>_GLIBCXX_DEPRECATED</code></dt>
    <dd>Defined by default. Not configurable. ABI-changing. Turning this off
        removes older ARM-style iostreams code, and other anachronisms
        from the API.  This macro is dependent on the version of the
        standard being tracked, and as a result may give different results for
        <code>-std=c++98</code> and <code>-std=c++0x</code>. This may
        be useful in updating old C++ code which no longer meet the
        requirements of the language, or for checking current code
        against new language standards.  </dd>

    <dt><code>_GLIBCXX_FORCE_NEW</code></dt> <dd>Undefined by
    default. When defined, memory allocation and allocators controlled
    by libstdc++ call operator new/delete without caching and
    pooling. Configurable via
    <code>--enable-libstdcxx-allocator</code>. ABI-changing.</a>
    </dd>


    <dt><code>_GLIBCXX_CONCEPT_CHECKS</code></dt> <dd>Undefined by
    default.  Configurable via <code>--enable-concept-checks</code>.
    When defined, performs compile-time checking on certain template
    instantiations to detect violations of the requirements of the
    standard.  This is described in more detail <a
    href="../19_diagnostics/howto.html#3">here</a>.</dd>

    <dt><code>_GLIBCXX_DEBUG</code></dt>
    <dd>Undefined by default. When defined, compiles
    user code using the <a href="../ext/debug.html#safe">libstdc++ debug
    mode</a>.
    </dd>
    <dt><code>_GLIBCXX_DEBUG_PEDANTIC</code></dt>
    <dd>Undefined by default. When defined while
    compiling with the <a href="../ext/debug.html#safe">libstdc++ debug
    mode</a>, makes the debug mode extremely picky by making the use
    of libstdc++ extensions and libstdc++-specific behavior into
    errors.
    </dd>
    <dt><code>_GLIBCXX_PARALLEL</code></dt>
    <dd>Undefined by default. When defined, compiles
    user code using the <a href="../ext/parallel_mode.html">libstdc++ parallel
    mode</a>.
    </dd>

    <!--
    <dt><code></code></dt>
    <dd>
    </dd>
    -->
    </dl>
   <p>Return <a href="#top">to top of page</a> or
      <a href="../faq/index.html">to the FAQ</a>.
   </p>



<!-- ####################################################### -->

<hr />
<p class="fineprint"><em>
See <a href="license.html">license.html</a> for copying conditions.
Comments and suggestions are welcome, and may be sent to
<a href="mailto:libstdc++@gcc.gnu.org">the libstdc++ mailing list</a>.
</em></p>


</body>
</html>


